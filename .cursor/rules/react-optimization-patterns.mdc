---
alwaysApply: false
description: React optimization patterns for deriving state instead of using additional state and useEffect
---

# React Optimization Patterns: Deriving State Instead of useEffect

## Core Principle

When something can be calculated from existing props or state, **derive it during rendering** instead of storing it in state and updating it with useEffect. This follows the React principle of "deriving state from props" rather than "synchronizing state with props."

## When to Use Derived State

### ✅ Good: Derive values during rendering

```typescript
// Instead of storing calculated values in state
const [fullName, setFullName] = useState("");

useEffect(() => {
  setFullName(firstName + " " + lastName);
}, [firstName, lastName]);

// ✅ Calculate during rendering
const fullName = firstName + " " + lastName;
```

### ✅ Good: Use useMemo for expensive calculations

```typescript
// For expensive calculations that depend on props/state
const filteredRecipients = useMemo(() => {
  return recipients.filter((recipient) => {
    if (!selectedAccount) return false;
    if (selectedAccount.category === "LIMITED_DDA") {
      return (
        recipient.type === "LINKED_ACCOUNT" && recipient.status === "ACTIVE"
      );
    }
    return true;
  });
}, [recipients, selectedAccount]);
```

### ✅ Good: Derive complex state objects

```typescript
// Instead of managing multiple state variables with useEffect
const recipientSelectionState = useMemo(() => {
  if (!recipientId || filteredRecipients.length === 0) {
    return { shouldSelectRecipient: false, recipientNotFound: false };
  }

  const recipientExists = filteredRecipients.some((r) => r.id === recipientId);

  if (recipientExists) {
    // Auto-select if no recipient is currently selected
    const currentRecipient = form.getValues("to");
    if (!currentRecipient) {
      form.setValue("to", recipientId);
    }
    return { shouldSelectRecipient: false, recipientNotFound: false };
  }

  return { shouldSelectRecipient: false, recipientNotFound: true };
}, [recipientId, filteredRecipients, form]);

const { recipientNotFound } = recipientSelectionState;
```

## When to Use useEffect

### ✅ Valid: Synchronizing with external systems

```typescript
// Data fetching
useEffect(() => {
  let ignore = false;
  fetchResults(query, page).then((json) => {
    if (!ignore) {
      setResults(json);
    }
  });
  return () => {
    ignore = true;
  };
}, [query, page]);

// DOM manipulation
useEffect(() => {
  const handleResize = () =>
    setWindowSize({ width: window.innerWidth, height: window.innerHeight });
  window.addEventListener("resize", handleResize);
  return () => window.removeEventListener("resize", handleResize);
}, []);
```

### ❌ Avoid: Synchronizing state with props

```typescript
// Don't do this
const [recipientNotFound, setRecipientNotFound] = useState(false);

useEffect(() => {
  if (recipientId && filteredRecipients.length > 0) {
    const recipientExists = filteredRecipients.some(
      (r) => r.id === recipientId
    );
    setRecipientNotFound(!recipientExists);
  } else {
    setRecipientNotFound(false);
  }
}, [recipientId, filteredRecipients]);
```

## Benefits of Derived State

1. **Performance**: Eliminates unnecessary re-renders from cascading state updates
2. **Simplicity**: Reduces code complexity and state management
3. **Predictability**: Values are always in sync with their dependencies
4. **Debugging**: Easier to trace data flow and identify issues

## Implementation Patterns

### Pattern 1: Simple Derivation

```typescript
// Calculate during render
const totalAmount = amount + fee;
const isAmountValid = amount > fee && totalAmount <= availableBalance;
```

### Pattern 2: Complex Derivation with useMemo

```typescript
const derivedState = useMemo(() => {
  // Complex logic here
  return {
    computedValue1: /* calculation */,
    computedValue2: /* calculation */,
    shouldShowWarning: /* condition */
  };
}, [dependency1, dependency2]);
```

### Pattern 3: Conditional Rendering Based on Derived State

```typescript
{
  recipientNotFound && (
    <div className="text-destructive">
      {t("warnings.recipientNotFound", { recipientId })}
    </div>
  );
}
```

## Checklist for Refactoring

When reviewing code that uses useEffect for state synchronization:

1. **Can this value be calculated from existing props/state?**

   - If yes, derive it during rendering

2. **Is the calculation expensive?**

   - If yes, wrap in useMemo

3. **Does the useEffect only update state based on props/state changes?**

   - If yes, consider deriving instead

4. **Is the useEffect synchronizing with an external system?**
   - If yes, useEffect is appropriate

## References

- [React Documentation: You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
- [Thinking in React: What Should Go Into State](https://react.dev/learn/thinking-in-react#step-3-identify-the-minimal-but-complete-state)
