/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * Embedded Banking Solutions API
 * Embedded Banking Solutions services from J.P. Morgan
 * OpenAPI spec version: 2.0.3
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  400DoResponse,
  400RecipientsResponse,
  400Response,
  400v2Response,
  401DoResponse,
  401Response,
  401v2Response,
  403DoResponse,
  403Response,
  403v2Response,
  404DoResponse,
  404Response,
  404v2Response,
  422DoResponse,
  500DoResponse,
  500Response,
  500v2Response,
  503DoResponse,
  503Response,
  503v2Response,
  AccountBalanceResponse,
  AccountResponseWithStatus,
  CardDetailResponse,
  CardDetailsErrorResponse,
  CardUpdateRequest,
  CardUpdateResponse,
  CaseCreateRequest,
  CaseCreateResponse,
  CaseDetails,
  CaseUpdateRequest,
  CasesPaginationResponse,
  ClientListResponse,
  ClientResponse,
  CreateAccountRequest,
  CreateClientRequestSmbdo,
  CreateDebitCardRequest,
  CreateDebitCardResponse,
  CreatePartyRequest,
  CreateUserRequest,
  DebitCardsResponse,
  DocumentRequestListResponse,
  DocumentRequestResponse,
  GetAccountsParams,
  GetAllRecipientsParams,
  GetAllUsersParams,
  GetCasesParams,
  GetDebitCardsParams,
  ListAccountsResponse,
  ListDocumentsResponse,
  ListRecipientsResponse,
  ListTransactionsSearchResponseV2,
  ListTransactionsV2Params,
  ListUserResponse,
  ListWebhookResponse,
  ListWebhooksParams,
  MicrodepositAmounts,
  MicrodepositVerificationResponse,
  PartyListResponse,
  PartyResponse,
  PostTransactionRequestV2,
  QuestionListResponse,
  Recipient,
  RecipientRequest,
  SchemasQuestionResponse,
  SearchStatementsParams,
  SmbdoDownloadDocument200Six,
  SmbdoGetAllDocumentDetailsParams,
  SmbdoListClientsParams,
  SmbdoListDocumentRequestsParams,
  SmbdoListPartiesParams,
  SmbdoListQuestionsParams,
  StatementsResponse,
  TransactionGetResponseV2,
  TransactionResponseV2,
  UpdateClientRequestSmbdo,
  UpdatePartyRequest,
  UpdateRecipientRequest,
  UpdateUserRequest,
  User400ClientIdResponse,
  User400Response,
  User401Response,
  User403Response,
  User404Response,
  User500Response,
  User503Response,
  UserResponse,
  WebhookRequest,
  WebhookResponse,
  WebhookUpdateRequest
} from './embedded-banking.schemas'



/**
 * Returns a list of clients associated with your platform.
 * @summary List clients
 */
export const smbdoListClients = (
    params?: SmbdoListClientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClientListResponse>> => {
    
    return axios.get(
      `/clients`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSmbdoListClientsQueryKey = (params?: SmbdoListClientsParams,) => {
    return [`/clients`, ...(params ? [params]: [])] as const;
    }

    
export const getSmbdoListClientsQueryOptions = <TData = Awaited<ReturnType<typeof smbdoListClients>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(params?: SmbdoListClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListClients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoListClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoListClients>>> = ({ signal }) => smbdoListClients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoListClients>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoListClientsQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoListClients>>>
export type SmbdoListClientsQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary List clients
 */
export const useSmbdoListClients = <TData = Awaited<ReturnType<typeof smbdoListClients>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 params?: SmbdoListClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListClients>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoListClientsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a client.
 * @summary Create client
 */
export const smbdoPostClients = (
    createClientRequestSmbdo: CreateClientRequestSmbdo, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClientResponse>> => {
    
    return axios.post(
      `/clients`,
      createClientRequestSmbdo,options
    );
  }



export const getSmbdoPostClientsMutationOptions = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClients>>, TError,{data: CreateClientRequestSmbdo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClients>>, TError,{data: CreateClientRequestSmbdo}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smbdoPostClients>>, {data: CreateClientRequestSmbdo}> = (props) => {
          const {data} = props ?? {};

          return  smbdoPostClients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmbdoPostClientsMutationResult = NonNullable<Awaited<ReturnType<typeof smbdoPostClients>>>
    export type SmbdoPostClientsMutationBody = CreateClientRequestSmbdo
    export type SmbdoPostClientsMutationError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

    /**
 * @summary Create client
 */
export const useSmbdoPostClients = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClients>>, TError,{data: CreateClientRequestSmbdo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof smbdoPostClients>>,
        TError,
        {data: CreateClientRequestSmbdo},
        TContext
      > => {

      const mutationOptions = getSmbdoPostClientsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve client details by its ID.
 * @summary Get client
 */
export const smbdoGetClient = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClientResponse>> => {
    
    return axios.get(
      `/clients/${id}`,options
    );
  }


export const getSmbdoGetClientQueryKey = (id: string,) => {
    return [`/clients/${id}`] as const;
    }

    
export const getSmbdoGetClientQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetClient>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetClient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetClientQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetClient>>> = ({ signal }) => smbdoGetClient(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetClient>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetClientQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetClient>>>
export type SmbdoGetClientQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Get client
 */
export const useSmbdoGetClient = <TData = Awaited<ReturnType<typeof smbdoGetClient>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetClient>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetClientQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a client.
 * @summary Update client
 */
export const smbdoUpdateClient = (
    id: string,
    updateClientRequestSmbdo: UpdateClientRequestSmbdo, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClientResponse>> => {
    
    return axios.post(
      `/clients/${id}`,
      updateClientRequestSmbdo,options
    );
  }



export const getSmbdoUpdateClientMutationOptions = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateClient>>, TError,{id: string;data: UpdateClientRequestSmbdo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateClient>>, TError,{id: string;data: UpdateClientRequestSmbdo}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smbdoUpdateClient>>, {id: string;data: UpdateClientRequestSmbdo}> = (props) => {
          const {id,data} = props ?? {};

          return  smbdoUpdateClient(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmbdoUpdateClientMutationResult = NonNullable<Awaited<ReturnType<typeof smbdoUpdateClient>>>
    export type SmbdoUpdateClientMutationBody = UpdateClientRequestSmbdo
    export type SmbdoUpdateClientMutationError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

    /**
 * @summary Update client
 */
export const useSmbdoUpdateClient = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateClient>>, TError,{id: string;data: UpdateClientRequestSmbdo}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof smbdoUpdateClient>>,
        TError,
        {id: string;data: UpdateClientRequestSmbdo},
        TContext
      > => {

      const mutationOptions = getSmbdoUpdateClientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Performs client verifications
 * @summary Perform client verifications
 */
export const smbdoPostClientVerifications = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/clients/${id}/verifications`,undefined,options
    );
  }



export const getSmbdoPostClientVerificationsMutationOptions = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 422DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClientVerifications>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClientVerifications>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smbdoPostClientVerifications>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  smbdoPostClientVerifications(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmbdoPostClientVerificationsMutationResult = NonNullable<Awaited<ReturnType<typeof smbdoPostClientVerifications>>>
    
    export type SmbdoPostClientVerificationsMutationError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 422DoResponse | 500DoResponse | 503DoResponse>

    /**
 * @summary Perform client verifications
 */
export const useSmbdoPostClientVerifications = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 422DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostClientVerifications>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof smbdoPostClientVerifications>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSmbdoPostClientVerificationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a list of parties.
 * @summary List parties
 */
export const smbdoListParties = (
    params?: SmbdoListPartiesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PartyListResponse>> => {
    
    return axios.get(
      `/parties`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSmbdoListPartiesQueryKey = (params?: SmbdoListPartiesParams,) => {
    return [`/parties`, ...(params ? [params]: [])] as const;
    }

    
export const getSmbdoListPartiesQueryOptions = <TData = Awaited<ReturnType<typeof smbdoListParties>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(params?: SmbdoListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListParties>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoListPartiesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoListParties>>> = ({ signal }) => smbdoListParties(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoListParties>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoListPartiesQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoListParties>>>
export type SmbdoListPartiesQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary List parties
 */
export const useSmbdoListParties = <TData = Awaited<ReturnType<typeof smbdoListParties>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 params?: SmbdoListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListParties>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoListPartiesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new party.
 * @summary Create party
 */
export const smbdoPostParties = (
    createPartyRequest: CreatePartyRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PartyResponse>> => {
    
    return axios.post(
      `/parties`,
      createPartyRequest,options
    );
  }



export const getSmbdoPostPartiesMutationOptions = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostParties>>, TError,{data: CreatePartyRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smbdoPostParties>>, TError,{data: CreatePartyRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smbdoPostParties>>, {data: CreatePartyRequest}> = (props) => {
          const {data} = props ?? {};

          return  smbdoPostParties(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmbdoPostPartiesMutationResult = NonNullable<Awaited<ReturnType<typeof smbdoPostParties>>>
    export type SmbdoPostPartiesMutationBody = CreatePartyRequest
    export type SmbdoPostPartiesMutationError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

    /**
 * @summary Create party
 */
export const useSmbdoPostParties = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoPostParties>>, TError,{data: CreatePartyRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof smbdoPostParties>>,
        TError,
        {data: CreatePartyRequest},
        TContext
      > => {

      const mutationOptions = getSmbdoPostPartiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Details a party by its unique identifier.
 * @summary Get party
 */
export const smbdoGetParty = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PartyResponse>> => {
    
    return axios.get(
      `/parties/${id}`,options
    );
  }


export const getSmbdoGetPartyQueryKey = (id: string,) => {
    return [`/parties/${id}`] as const;
    }

    
export const getSmbdoGetPartyQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetParty>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetParty>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetPartyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetParty>>> = ({ signal }) => smbdoGetParty(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetParty>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetPartyQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetParty>>>
export type SmbdoGetPartyQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Get party
 */
export const useSmbdoGetParty = <TData = Awaited<ReturnType<typeof smbdoGetParty>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetParty>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetPartyQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a party.
 * @summary Update party
 */
export const smbdoUpdateParty = (
    id: string,
    updatePartyRequest: UpdatePartyRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PartyResponse>> => {
    
    return axios.post(
      `/parties/${id}`,
      updatePartyRequest,options
    );
  }



export const getSmbdoUpdatePartyMutationOptions = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateParty>>, TError,{id: string;data: UpdatePartyRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateParty>>, TError,{id: string;data: UpdatePartyRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smbdoUpdateParty>>, {id: string;data: UpdatePartyRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  smbdoUpdateParty(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmbdoUpdatePartyMutationResult = NonNullable<Awaited<ReturnType<typeof smbdoUpdateParty>>>
    export type SmbdoUpdatePartyMutationBody = UpdatePartyRequest
    export type SmbdoUpdatePartyMutationError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

    /**
 * @summary Update party
 */
export const useSmbdoUpdateParty = <TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smbdoUpdateParty>>, TError,{id: string;data: UpdatePartyRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof smbdoUpdateParty>>,
        TError,
        {id: string;data: UpdatePartyRequest},
        TContext
      > => {

      const mutationOptions = getSmbdoUpdatePartyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Lists customer due diligence questions.

 * @summary List questions
 */
export const smbdoListQuestions = (
    params?: SmbdoListQuestionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionListResponse>> => {
    
    return axios.get(
      `/questions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSmbdoListQuestionsQueryKey = (params?: SmbdoListQuestionsParams,) => {
    return [`/questions`, ...(params ? [params]: [])] as const;
    }

    
export const getSmbdoListQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof smbdoListQuestions>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(params?: SmbdoListQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoListQuestionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoListQuestions>>> = ({ signal }) => smbdoListQuestions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoListQuestions>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoListQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoListQuestions>>>
export type SmbdoListQuestionsQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary List questions
 */
export const useSmbdoListQuestions = <TData = Awaited<ReturnType<typeof smbdoListQuestions>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 params?: SmbdoListQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListQuestions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoListQuestionsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a customer due diligence question.

 * @summary Get question
 */
export const smbdoGetQuestion = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SchemasQuestionResponse>> => {
    
    return axios.get(
      `/questions/${id}`,options
    );
  }


export const getSmbdoGetQuestionQueryKey = (id: string,) => {
    return [`/questions/${id}`] as const;
    }

    
export const getSmbdoGetQuestionQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetQuestion>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetQuestionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetQuestion>>> = ({ signal }) => smbdoGetQuestion(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetQuestion>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetQuestion>>>
export type SmbdoGetQuestionQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Get question
 */
export const useSmbdoGetQuestion = <TData = Awaited<ReturnType<typeof smbdoGetQuestion>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetQuestion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetQuestionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves a list of document details.

 * @summary List document details
 */
export const smbdoGetAllDocumentDetails = (
    params?: SmbdoGetAllDocumentDetailsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDocumentsResponse>> => {
    
    return axios.get(
      `/documents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSmbdoGetAllDocumentDetailsQueryKey = (params?: SmbdoGetAllDocumentDetailsParams,) => {
    return [`/documents`, ...(params ? [params]: [])] as const;
    }

    
export const getSmbdoGetAllDocumentDetailsQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(params?: SmbdoGetAllDocumentDetailsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetAllDocumentDetailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>> = ({ signal }) => smbdoGetAllDocumentDetails(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetAllDocumentDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>>
export type SmbdoGetAllDocumentDetailsQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary List document details
 */
export const useSmbdoGetAllDocumentDetails = <TData = Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 params?: SmbdoGetAllDocumentDetailsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetAllDocumentDetails>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetAllDocumentDetailsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve details of a document.

 * @summary Get document details
 */
export const smbdoGetDocumentDetail = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDocumentsResponse>> => {
    
    return axios.get(
      `/documents/${id}`,options
    );
  }


export const getSmbdoGetDocumentDetailQueryKey = (id: string,) => {
    return [`/documents/${id}`] as const;
    }

    
export const getSmbdoGetDocumentDetailQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetDocumentDetail>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetDocumentDetailQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetDocumentDetail>>> = ({ signal }) => smbdoGetDocumentDetail(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetDocumentDetailQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetDocumentDetail>>>
export type SmbdoGetDocumentDetailQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Get document details
 */
export const useSmbdoGetDocumentDetail = <TData = Awaited<ReturnType<typeof smbdoGetDocumentDetail>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentDetail>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetDocumentDetailQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Download a document using its unique identifier.
 * @summary Download a document
 */
export const smbdoDownloadDocument = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string | SmbdoDownloadDocument200Six>> => {
    
    return axios.get(
      `/documents/${id}/file`,options
    );
  }


export const getSmbdoDownloadDocumentQueryKey = (id: string,) => {
    return [`/documents/${id}/file`] as const;
    }

    
export const getSmbdoDownloadDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smbdoDownloadDocument>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoDownloadDocumentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoDownloadDocument>>> = ({ signal }) => smbdoDownloadDocument(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoDownloadDocument>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoDownloadDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoDownloadDocument>>>
export type SmbdoDownloadDocumentQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Download a document
 */
export const useSmbdoDownloadDocument = <TData = Awaited<ReturnType<typeof smbdoDownloadDocument>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoDownloadDocumentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a list of document requests.

 * @summary List document requests
 */
export const smbdoListDocumentRequests = (
    params?: SmbdoListDocumentRequestsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DocumentRequestListResponse>> => {
    
    return axios.get(
      `/document-requests`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSmbdoListDocumentRequestsQueryKey = (params?: SmbdoListDocumentRequestsParams,) => {
    return [`/document-requests`, ...(params ? [params]: [])] as const;
    }

    
export const getSmbdoListDocumentRequestsQueryOptions = <TData = Awaited<ReturnType<typeof smbdoListDocumentRequests>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(params?: SmbdoListDocumentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListDocumentRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoListDocumentRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoListDocumentRequests>>> = ({ signal }) => smbdoListDocumentRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoListDocumentRequests>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoListDocumentRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoListDocumentRequests>>>
export type SmbdoListDocumentRequestsQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary List document requests
 */
export const useSmbdoListDocumentRequests = <TData = Awaited<ReturnType<typeof smbdoListDocumentRequests>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 params?: SmbdoListDocumentRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoListDocumentRequests>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoListDocumentRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns details for a document request using its unique identifier.
 * @summary Get document request
 */
export const smbdoGetDocumentRequest = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DocumentRequestResponse>> => {
    
    return axios.get(
      `/document-requests/${id}`,options
    );
  }


export const getSmbdoGetDocumentRequestQueryKey = (id: string,) => {
    return [`/document-requests/${id}`] as const;
    }

    
export const getSmbdoGetDocumentRequestQueryOptions = <TData = Awaited<ReturnType<typeof smbdoGetDocumentRequest>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmbdoGetDocumentRequestQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smbdoGetDocumentRequest>>> = ({ signal }) => smbdoGetDocumentRequest(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentRequest>>, TError, TData> & { queryKey: QueryKey }
}

export type SmbdoGetDocumentRequestQueryResult = NonNullable<Awaited<ReturnType<typeof smbdoGetDocumentRequest>>>
export type SmbdoGetDocumentRequestQueryError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>

/**
 * @summary Get document request
 */
export const useSmbdoGetDocumentRequest = <TData = Awaited<ReturnType<typeof smbdoGetDocumentRequest>>, TError = AxiosError<400DoResponse | 401DoResponse | 403DoResponse | 404DoResponse | 500DoResponse | 503DoResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smbdoGetDocumentRequest>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSmbdoGetDocumentRequestQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of accounts for a specific client.
 * @summary List accounts
 */
export const getAccounts = (
    params?: GetAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountsResponse>> => {
    
    return axios.get(
      `/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAccountsQueryKey = (params?: GetAccountsParams,) => {
    return [`/accounts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAccountsQueryOptions = <TData = Awaited<ReturnType<typeof getAccounts>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(params?: GetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccounts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccounts>>> = ({ signal }) => getAccounts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccounts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getAccounts>>>
export type GetAccountsQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary List accounts
 */
export const useGetAccounts = <TData = Awaited<ReturnType<typeof getAccounts>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 params?: GetAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccounts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccountsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create an account for a specific client
 * @summary Create account
 */
export const postAccounts = (
    createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountResponseWithStatus>> => {
    
    return axios.post(
      `/accounts`,
      createAccountRequest,options
    );
  }



export const getPostAccountsMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccounts>>, TError,{data: CreateAccountRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAccounts>>, TError,{data: CreateAccountRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAccounts>>, {data: CreateAccountRequest}> = (props) => {
          const {data} = props ?? {};

          return  postAccounts(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof postAccounts>>>
    export type PostAccountsMutationBody = CreateAccountRequest
    export type PostAccountsMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Create account
 */
export const usePostAccounts = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccounts>>, TError,{data: CreateAccountRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAccounts>>,
        TError,
        {data: CreateAccountRequest},
        TContext
      > => {

      const mutationOptions = getPostAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Look up a single account by account ID
 * @summary Get account
 */
export const getAccount = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountResponseWithStatus>> => {
    
    return axios.get(
      `/accounts/${id}`,options
    );
  }


export const getGetAccountQueryKey = (id: string,) => {
    return [`/accounts/${id}`] as const;
    }

    
export const getGetAccountQueryOptions = <TData = Awaited<ReturnType<typeof getAccount>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccount>>> = ({ signal }) => getAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getAccount>>>
export type GetAccountQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get account
 */
export const useGetAccount = <TData = Awaited<ReturnType<typeof getAccount>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get the balance details for an account
 * @summary Get an account balance
 */
export const getAccountBalance = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountBalanceResponse>> => {
    
    return axios.get(
      `/accounts/${id}/balances`,options
    );
  }


export const getGetAccountBalanceQueryKey = (id: string,) => {
    return [`/accounts/${id}/balances`] as const;
    }

    
export const getGetAccountBalanceQueryOptions = <TData = Awaited<ReturnType<typeof getAccountBalance>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountBalance>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountBalanceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountBalance>>> = ({ signal }) => getAccountBalance(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountBalance>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountBalance>>>
export type GetAccountBalanceQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get an account balance
 */
export const useGetAccountBalance = <TData = Awaited<ReturnType<typeof getAccountBalance>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountBalance>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccountBalanceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of all recipients for a given client profile.
 * @summary List recipients
 */
export const getAllRecipients = (
    params?: GetAllRecipientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListRecipientsResponse>> => {
    
    return axios.get(
      `/recipients`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAllRecipientsQueryKey = (params?: GetAllRecipientsParams,) => {
    return [`/recipients`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllRecipientsQueryOptions = <TData = Awaited<ReturnType<typeof getAllRecipients>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(params?: GetAllRecipientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRecipients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllRecipientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRecipients>>> = ({ signal }) => getAllRecipients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllRecipients>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllRecipientsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllRecipients>>>
export type GetAllRecipientsQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary List recipients
 */
export const useGetAllRecipients = <TData = Awaited<ReturnType<typeof getAllRecipients>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 params?: GetAllRecipientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRecipients>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllRecipientsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new recipient.
 * @summary Create recipient
 */
export const createRecipient = (
    recipientRequest: RecipientRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipient>> => {
    
    return axios.post(
      `/recipients`,
      recipientRequest,options
    );
  }



export const getCreateRecipientMutationOptions = <TError = AxiosError<400RecipientsResponse | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipient>>, TError,{data: RecipientRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRecipient>>, TError,{data: RecipientRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRecipient>>, {data: RecipientRequest}> = (props) => {
          const {data} = props ?? {};

          return  createRecipient(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRecipientMutationResult = NonNullable<Awaited<ReturnType<typeof createRecipient>>>
    export type CreateRecipientMutationBody = RecipientRequest
    export type CreateRecipientMutationError = AxiosError<400RecipientsResponse | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Create recipient
 */
export const useCreateRecipient = <TError = AxiosError<400RecipientsResponse | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipient>>, TError,{data: RecipientRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createRecipient>>,
        TError,
        {data: RecipientRequest},
        TContext
      > => {

      const mutationOptions = getCreateRecipientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns information about a specific recipient.
 * @summary Get recipient
 */
export const getRecipient = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipient>> => {
    
    return axios.get(
      `/recipients/${id}`,options
    );
  }


export const getGetRecipientQueryKey = (id: string,) => {
    return [`/recipients/${id}`] as const;
    }

    
export const getGetRecipientQueryOptions = <TData = Awaited<ReturnType<typeof getRecipient>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecipientQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipient>>> = ({ signal }) => getRecipient(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipient>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRecipientQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipient>>>
export type GetRecipientQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get recipient
 */
export const useGetRecipient = <TData = Awaited<ReturnType<typeof getRecipient>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipient>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecipientQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates details of a recipient, such as adding values for attributes related to payment types. All attributes must be provided in the same format as when creating a recipient. The value partyDetails.type cannot be amended after creation.
 * @summary Update recipient
 */
export const amendRecipient = (
    id: string,
    updateRecipientRequest: UpdateRecipientRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipient>> => {
    
    return axios.post(
      `/recipients/${id}`,
      updateRecipientRequest,options
    );
  }



export const getAmendRecipientMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof amendRecipient>>, TError,{id: string;data: UpdateRecipientRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof amendRecipient>>, TError,{id: string;data: UpdateRecipientRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof amendRecipient>>, {id: string;data: UpdateRecipientRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  amendRecipient(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AmendRecipientMutationResult = NonNullable<Awaited<ReturnType<typeof amendRecipient>>>
    export type AmendRecipientMutationBody = UpdateRecipientRequest
    export type AmendRecipientMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Update recipient
 */
export const useAmendRecipient = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof amendRecipient>>, TError,{id: string;data: UpdateRecipientRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof amendRecipient>>,
        TError,
        {id: string;data: UpdateRecipientRequest},
        TContext
      > => {

      const mutationOptions = getAmendRecipientMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Creates a microdeposits verification process.
 * @summary Creates a microdeposits verification process.
 */
export const recipientsVerification = (
    id: string,
    microdepositAmounts: MicrodepositAmounts, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MicrodepositVerificationResponse>> => {
    
    return axios.post(
      `/recipients/${id}/verify-microdeposit`,
      microdepositAmounts,options
    );
  }



export const getRecipientsVerificationMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipientsVerification>>, TError,{id: string;data: MicrodepositAmounts}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipientsVerification>>, TError,{id: string;data: MicrodepositAmounts}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipientsVerification>>, {id: string;data: MicrodepositAmounts}> = (props) => {
          const {id,data} = props ?? {};

          return  recipientsVerification(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipientsVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof recipientsVerification>>>
    export type RecipientsVerificationMutationBody = MicrodepositAmounts
    export type RecipientsVerificationMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Creates a microdeposits verification process.
 */
export const useRecipientsVerification = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipientsVerification>>, TError,{id: string;data: MicrodepositAmounts}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof recipientsVerification>>,
        TError,
        {id: string;data: MicrodepositAmounts},
        TContext
      > => {

      const mutationOptions = getRecipientsVerificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Lists transactions for a specific client, which can be filtered using optional parameters.
 * @summary List transactions
 */
export const listTransactionsV2 = (
    params?: ListTransactionsV2Params, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListTransactionsSearchResponseV2>> => {
    
    return axios.get(
      `/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getListTransactionsV2QueryKey = (params?: ListTransactionsV2Params,) => {
    return [`/transactions`, ...(params ? [params]: [])] as const;
    }

    
export const getListTransactionsV2QueryOptions = <TData = Awaited<ReturnType<typeof listTransactionsV2>>, TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>>(params?: ListTransactionsV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTransactionsV2>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTransactionsV2QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTransactionsV2>>> = ({ signal }) => listTransactionsV2(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTransactionsV2>>, TError, TData> & { queryKey: QueryKey }
}

export type ListTransactionsV2QueryResult = NonNullable<Awaited<ReturnType<typeof listTransactionsV2>>>
export type ListTransactionsV2QueryError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>

/**
 * @summary List transactions
 */
export const useListTransactionsV2 = <TData = Awaited<ReturnType<typeof listTransactionsV2>>, TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>>(
 params?: ListTransactionsV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTransactionsV2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListTransactionsV2QueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new transaction, such as a payment via ACH, Wire or Real Time Payments (RTP).
 * @summary Create transaction
 */
export const createTransactionV2 = (
    postTransactionRequestV2: PostTransactionRequestV2, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionResponseV2>> => {
    
    return axios.post(
      `/transactions`,
      postTransactionRequestV2,options
    );
  }



export const getCreateTransactionV2MutationOptions = <TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransactionV2>>, TError,{data: PostTransactionRequestV2}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createTransactionV2>>, TError,{data: PostTransactionRequestV2}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTransactionV2>>, {data: PostTransactionRequestV2}> = (props) => {
          const {data} = props ?? {};

          return  createTransactionV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof createTransactionV2>>>
    export type CreateTransactionV2MutationBody = PostTransactionRequestV2
    export type CreateTransactionV2MutationError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>

    /**
 * @summary Create transaction
 */
export const useCreateTransactionV2 = <TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransactionV2>>, TError,{data: PostTransactionRequestV2}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createTransactionV2>>,
        TError,
        {data: PostTransactionRequestV2},
        TContext
      > => {

      const mutationOptions = getCreateTransactionV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns details for a specific transaction using its unique identifier.
 * @summary Get transaction
 */
export const getTransactionV2 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionGetResponseV2>> => {
    
    return axios.get(
      `/transactions/${id}`,options
    );
  }


export const getGetTransactionV2QueryKey = (id: string,) => {
    return [`/transactions/${id}`] as const;
    }

    
export const getGetTransactionV2QueryOptions = <TData = Awaited<ReturnType<typeof getTransactionV2>>, TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionV2>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionV2QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionV2>>> = ({ signal }) => getTransactionV2(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionV2>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTransactionV2QueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionV2>>>
export type GetTransactionV2QueryError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>

/**
 * @summary Get transaction
 */
export const useGetTransactionV2 = <TData = Awaited<ReturnType<typeof getTransactionV2>>, TError = AxiosError<400v2Response | 401v2Response | 403v2Response | 404v2Response | 500v2Response | 503v2Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionV2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTransactionV2QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a statement document using its identifier
 * @summary Get a statement
 */
export const getStatement = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `/statements/${id}`,options
    );
  }


export const getGetStatementQueryKey = (id: string,) => {
    return [`/statements/${id}`] as const;
    }

    
export const getGetStatementQueryOptions = <TData = Awaited<ReturnType<typeof getStatement>>, TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatement>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatementQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatement>>> = ({ signal }) => getStatement(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatement>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatementQueryResult = NonNullable<Awaited<ReturnType<typeof getStatement>>>
export type GetStatementQueryError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get a statement
 */
export const useGetStatement = <TData = Awaited<ReturnType<typeof getStatement>>, TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatement>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatementQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns statements filtered by search criteria.
 * @summary Search statements
 */
export const searchStatements = (
    params: SearchStatementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatementsResponse>> => {
    
    return axios.get(
      `/statements/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchStatementsQueryKey = (params: SearchStatementsParams,) => {
    return [`/statements/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchStatementsQueryOptions = <TData = Awaited<ReturnType<typeof searchStatements>>, TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>>(params: SearchStatementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStatements>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchStatementsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStatements>>> = ({ signal }) => searchStatements(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchStatements>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchStatementsQueryResult = NonNullable<Awaited<ReturnType<typeof searchStatements>>>
export type SearchStatementsQueryError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Search statements
 */
export const useSearchStatements = <TData = Awaited<ReturnType<typeof searchStatements>>, TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>>(
 params: SearchStatementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStatements>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSearchStatementsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get cases for client profile
 * @summary Returns all cases for client profile.
 */
export const getCases = (
    params?: GetCasesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CasesPaginationResponse>> => {
    
    return axios.get(
      `/cases`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetCasesQueryKey = (params?: GetCasesParams,) => {
    return [`/cases`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCasesQueryOptions = <TData = Awaited<ReturnType<typeof getCases>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(params?: GetCasesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCases>>> = ({ signal }) => getCases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCases>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCasesQueryResult = NonNullable<Awaited<ReturnType<typeof getCases>>>
export type GetCasesQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Returns all cases for client profile.
 */
export const useGetCases = <TData = Awaited<ReturnType<typeof getCases>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 params?: GetCasesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCases>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCasesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Raises a case for support with Embedded Finance.
 * @summary Create a new case
 */
export const createCase = (
    caseCreateRequest: CaseCreateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CaseCreateResponse>> => {
    
    return axios.post(
      `/cases`,
      caseCreateRequest,options
    );
  }



export const getCreateCaseMutationOptions = <TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCase>>, TError,{data: CaseCreateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createCase>>, TError,{data: CaseCreateRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCase>>, {data: CaseCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCase(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCaseMutationResult = NonNullable<Awaited<ReturnType<typeof createCase>>>
    export type CreateCaseMutationBody = CaseCreateRequest
    export type CreateCaseMutationError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Create a new case
 */
export const useCreateCase = <TError = AxiosError<401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCase>>, TError,{data: CaseCreateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createCase>>,
        TError,
        {data: CaseCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateCaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get case details
 * @summary Returns details of a case using the unique case ID.
 */
export const getCase = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CaseDetails>> => {
    
    return axios.get(
      `/cases/${id}`,options
    );
  }


export const getGetCaseQueryKey = (id: string,) => {
    return [`/cases/${id}`] as const;
    }

    
export const getGetCaseQueryOptions = <TData = Awaited<ReturnType<typeof getCase>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCase>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCaseQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCase>>> = ({ signal }) => getCase(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCase>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCaseQueryResult = NonNullable<Awaited<ReturnType<typeof getCase>>>
export type GetCaseQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Returns details of a case using the unique case ID.
 */
export const useGetCase = <TData = Awaited<ReturnType<typeof getCase>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCase>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCaseQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update case
 * @summary Update information on a specific case.
 */
export const updateCase = (
    id: string,
    caseUpdateRequest: CaseUpdateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CaseDetails>> => {
    
    return axios.post(
      `/cases/${id}`,
      caseUpdateRequest,options
    );
  }



export const getUpdateCaseMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCase>>, TError,{id: string;data: CaseUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateCase>>, TError,{id: string;data: CaseUpdateRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCase>>, {id: string;data: CaseUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCase(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCaseMutationResult = NonNullable<Awaited<ReturnType<typeof updateCase>>>
    export type UpdateCaseMutationBody = CaseUpdateRequest
    export type UpdateCaseMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Update information on a specific case.
 */
export const useUpdateCase = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCase>>, TError,{id: string;data: CaseUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateCase>>,
        TError,
        {id: string;data: CaseUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns a list of debit cards for a specific client.
 * @summary List cards
 */
export const getDebitCards = (
    params?: GetDebitCardsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DebitCardsResponse>> => {
    
    return axios.get(
      `/debit-cards`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetDebitCardsQueryKey = (params?: GetDebitCardsParams,) => {
    return [`/debit-cards`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDebitCardsQueryOptions = <TData = Awaited<ReturnType<typeof getDebitCards>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | CardDetailsErrorResponse>>(params?: GetDebitCardsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebitCards>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDebitCardsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDebitCards>>> = ({ signal }) => getDebitCards(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDebitCards>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDebitCardsQueryResult = NonNullable<Awaited<ReturnType<typeof getDebitCards>>>
export type GetDebitCardsQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | CardDetailsErrorResponse>

/**
 * @summary List cards
 */
export const useGetDebitCards = <TData = Awaited<ReturnType<typeof getDebitCards>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | CardDetailsErrorResponse>>(
 params?: GetDebitCardsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebitCards>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDebitCardsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new debit card.
 * @summary Create debit card
 */
export const createDebitCard = (
    createDebitCardRequest: CreateDebitCardRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateDebitCardResponse>> => {
    
    return axios.post(
      `/debit-cards`,
      createDebitCardRequest,options
    );
  }



export const getCreateDebitCardMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDebitCard>>, TError,{data: CreateDebitCardRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createDebitCard>>, TError,{data: CreateDebitCardRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDebitCard>>, {data: CreateDebitCardRequest}> = (props) => {
          const {data} = props ?? {};

          return  createDebitCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDebitCardMutationResult = NonNullable<Awaited<ReturnType<typeof createDebitCard>>>
    export type CreateDebitCardMutationBody = CreateDebitCardRequest
    export type CreateDebitCardMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Create debit card
 */
export const useCreateDebitCard = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDebitCard>>, TError,{data: CreateDebitCardRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createDebitCard>>,
        TError,
        {data: CreateDebitCardRequest},
        TContext
      > => {

      const mutationOptions = getCreateDebitCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns card ID and iFrame link for virtual card details for a specific card.
 * @summary Get card
 */
export const getDebitCard = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CardDetailResponse>> => {
    
    return axios.get(
      `/debit-cards/${id}`,options
    );
  }


export const getGetDebitCardQueryKey = (id: string,) => {
    return [`/debit-cards/${id}`] as const;
    }

    
export const getGetDebitCardQueryOptions = <TData = Awaited<ReturnType<typeof getDebitCard>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebitCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDebitCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDebitCard>>> = ({ signal }) => getDebitCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDebitCard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDebitCardQueryResult = NonNullable<Awaited<ReturnType<typeof getDebitCard>>>
export type GetDebitCardQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get card
 */
export const useGetDebitCard = <TData = Awaited<ReturnType<typeof getDebitCard>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebitCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDebitCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates card details, such as PIN reset or to lock a lost card.
 * @summary Update card
 */
export const updateCard = (
    id: string,
    cardUpdateRequest: CardUpdateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CardUpdateResponse>> => {
    
    return axios.post(
      `/debit-cards/${id}`,
      cardUpdateRequest,options
    );
  }



export const getUpdateCardMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCard>>, TError,{id: string;data: CardUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateCard>>, TError,{id: string;data: CardUpdateRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCard>>, {id: string;data: CardUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateCard>>>
    export type UpdateCardMutationBody = CardUpdateRequest
    export type UpdateCardMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Update card
 */
export const useUpdateCard = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCard>>, TError,{id: string;data: CardUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateCard>>,
        TError,
        {id: string;data: CardUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves list of users for a client. The API by default retrieves a lighter version of data.
 * @summary List users
 */
export const getAllUsers = (
    params?: GetAllUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListUserResponse>> => {
    
    return axios.get(
      `/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAllUsersQueryKey = (params?: GetAllUsersParams,) => {
    return [`/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<User400ClientIdResponse | User401Response | User403Response | User500Response | User503Response>>(params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = AxiosError<User400ClientIdResponse | User401Response | User403Response | User500Response | User503Response>

/**
 * @summary List users
 */
export const useGetAllUsers = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<User400ClientIdResponse | User401Response | User403Response | User500Response | User503Response>>(
 params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllUsersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a new user. This API is developed to enable clients to create a user for accessing and managing resources for that client. The payload has a property partyId. This partyId is used to add an existing party as a user. Phone field is optional when partyId is provided. When partyId is not provided, then phone field should be populated. When providing a role, if the role is a DEBIT_CARD_HOLDER then the resourceType and resourceId and action should be provided.
 * @summary Create user
 */
export const postUsers = (
    createUserRequest: CreateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    return axios.post(
      `/users`,
      createUserRequest,options
    );
  }



export const getPostUsersMutationOptions = <TError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: CreateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: CreateUserRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsers>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  postUsers(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postUsers>>>
    export type PostUsersMutationBody = CreateUserRequest
    export type PostUsersMutationError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>

    /**
 * @summary Create user
 */
export const usePostUsers = <TError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: CreateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postUsers>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getPostUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves details for a specific user.
 * @summary Get user
 */
export const getUserDetails = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    return axios.get(
      `/users/${id}`,options
    );
  }


export const getGetUserDetailsQueryKey = (id: string,) => {
    return [`/users/${id}`] as const;
    }

    
export const getGetUserDetailsQueryOptions = <TData = Awaited<ReturnType<typeof getUserDetails>>, TError = AxiosError<User401Response | User403Response | User404Response | User500Response | User503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserDetailsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserDetails>>> = ({ signal }) => getUserDetails(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserDetails>>>
export type GetUserDetailsQueryError = AxiosError<User401Response | User403Response | User404Response | User500Response | User503Response>

/**
 * @summary Get user
 */
export const useGetUserDetails = <TData = Awaited<ReturnType<typeof getUserDetails>>, TError = AxiosError<User401Response | User403Response | User404Response | User500Response | User503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserDetailsQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates information about user. For additional users only, full details like name, email, address phone and role can be updated.
 * @summary Update user
 */
export const updateUserById = (
    id: string,
    updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    return axios.post(
      `/users/${id}`,
      updateUserRequest,options
    );
  }



export const getUpdateUserByIdMutationOptions = <TError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserById>>, TError,{id: string;data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserById>>, TError,{id: string;data: UpdateUserRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserById>>, {id: string;data: UpdateUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUserById(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserById>>>
    export type UpdateUserByIdMutationBody = UpdateUserRequest
    export type UpdateUserByIdMutationError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>

    /**
 * @summary Update user
 */
export const useUpdateUserById = <TError = AxiosError<User400Response | User401Response | User403Response | User500Response | User503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserById>>, TError,{id: string;data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUserById>>,
        TError,
        {id: string;data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all your webhooks
 * @summary List webhooks
 */
export const listWebhooks = (
    params?: ListWebhooksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListWebhookResponse>> => {
    
    return axios.get(
      `/webhooks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getListWebhooksQueryKey = (params?: ListWebhooksParams,) => {
    return [`/webhooks`, ...(params ? [params]: [])] as const;
    }

    
export const getListWebhooksQueryOptions = <TData = Awaited<ReturnType<typeof listWebhooks>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(params?: ListWebhooksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWebhooks>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWebhooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWebhooks>>> = ({ signal }) => listWebhooks(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWebhooks>>, TError, TData> & { queryKey: QueryKey }
}

export type ListWebhooksQueryResult = NonNullable<Awaited<ReturnType<typeof listWebhooks>>>
export type ListWebhooksQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary List webhooks
 */
export const useListWebhooks = <TData = Awaited<ReturnType<typeof listWebhooks>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 params?: ListWebhooksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWebhooks>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListWebhooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a webhook subscription
 * @summary Create a webhook subscription.
 */
export const createWebhook = (
    webhookRequest: WebhookRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WebhookResponse>> => {
    
    return axios.post(
      `/webhooks`,
      webhookRequest,options
    );
  }



export const getCreateWebhookMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWebhook>>, TError,{data: WebhookRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createWebhook>>, TError,{data: WebhookRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWebhook>>, {data: WebhookRequest}> = (props) => {
          const {data} = props ?? {};

          return  createWebhook(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof createWebhook>>>
    export type CreateWebhookMutationBody = WebhookRequest
    export type CreateWebhookMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Create a webhook subscription.
 */
export const useCreateWebhook = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWebhook>>, TError,{data: WebhookRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createWebhook>>,
        TError,
        {data: WebhookRequest},
        TContext
      > => {

      const mutationOptions = getCreateWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get details of your subscription to a specific webhook.
 * @summary Get a webhook subscription by ID.
 */
export const getWebhook = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WebhookResponse>> => {
    
    return axios.get(
      `/webhooks/${id}`,options
    );
  }


export const getGetWebhookQueryKey = (id: string,) => {
    return [`/webhooks/${id}`] as const;
    }

    
export const getGetWebhookQueryOptions = <TData = Awaited<ReturnType<typeof getWebhook>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWebhook>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWebhookQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWebhook>>> = ({ signal }) => getWebhook(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof getWebhook>>>
export type GetWebhookQueryError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

/**
 * @summary Get a webhook subscription by ID.
 */
export const useGetWebhook = <TData = Awaited<ReturnType<typeof getWebhook>>, TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWebhook>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWebhookQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add or Remove webhook subscriptions and change a webhook status to ACTIVE or INACTIVE
 * @summary Update a webhook by ID.
 */
export const updateWebhook = (
    id: string,
    webhookUpdateRequest: WebhookUpdateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WebhookResponse>> => {
    
    return axios.post(
      `/webhooks/${id}`,
      webhookUpdateRequest,options
    );
  }



export const getUpdateWebhookMutationOptions = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWebhook>>, TError,{id: string;data: WebhookUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateWebhook>>, TError,{id: string;data: WebhookUpdateRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWebhook>>, {id: string;data: WebhookUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWebhook(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof updateWebhook>>>
    export type UpdateWebhookMutationBody = WebhookUpdateRequest
    export type UpdateWebhookMutationError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>

    /**
 * @summary Update a webhook by ID.
 */
export const useUpdateWebhook = <TError = AxiosError<400Response | 401Response | 403Response | 404Response | 500Response | 503Response>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWebhook>>, TError,{id: string;data: WebhookUpdateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateWebhook>>,
        TError,
        {id: string;data: WebhookUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
