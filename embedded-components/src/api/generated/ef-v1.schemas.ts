/**
 * Generated by orval v7.0.1 üç∫
 * Do not edit manually.
 * Embedded Banking Solutions API
 * Embedded Banking Solutions services from J.P. Morgan
 * OpenAPI spec version: 1.0.8
 */
export type ListPaymentIntentsParams = {
  /**
   * Recipient ID
   */
  recipientId?: string;
  /**
   * Payment intent status
   */
  status?: string;
};

export type GetBalanceHoldsParams = {
  /**
   * Account ID
   */
  accountId: string;
};

export type GetAccountsParams = {
  /**
   * Unique Client identifier
   */
  clientId?: ClientIdInQueryParameter;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type ListTransactionsParams = {
  /**
   * Filters by type of transaction.
   */
  transactionType?: RequestTransactionType;
  /**
   * Filters by transaction status.
   */
  status?: RequestTransactionStatus;
  /**
   * Filters by the Embedded Banking client account number connected to the transaction.
   */
  accountNumber?: string;
  /**
   * Filters by an exact amount.
   */
  amountEquals?: string;
  /**
   * Filters by amounts greater than a specified value.
   */
  amountGreaterThan?: string;
  /**
   * Filters by amounts less than a specified value.
   */
  amountLessThan?: string;
  /**
   * Filters transactions by an exact date.
   */
  dateEquals?: string;
  /**
   * Filters for transactions made after this date.
   */
  dateGreaterThan?: string;
  /**
   * Filters for transactions made before this date.
   */
  dateLessThan?: string;
  /**
   * Filters for transactions made after this date and time.
   */
  dateTimeGreaterThan?: string;
  /**
   * Filters for transactions made before this date and time.
   */
  dateTimeLessThan?: string;
  /**
   * Filters by the recipient's account number.
   */
  recipientAccount?: string;
  /**
   * Filters for a transaction that matches a specific transaction ID. The transaction ID is generated by Embedded Banking when a transaction is created or received.
   */
  transactionId?: string;
};

export type SearchStatementsParams = {
  /**
 * Account identifiers used to represent client accounts.

 */
  accountIds?: string[];
  /**
   * Earliest date in search range. Must be set at least one day earlier than dateTo.
   */
  dateFrom: string;
  /**
   * Latest date in search range. Must be set at least one day later than dateFrom.
   */
  dateTo: string;
};

export type GetClientIndustryCategoriesParams = {
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type GetDocumentTypesParams = {
  /**
   * Two-letter ISO code for a country, such as US for USA.
   */
  countryCode?: CountryCodeParameter;
  /**
   * Document category type.
   */
  documentCategory?: DocumentCategoryParameter;
  /**
   * url encoded legalStructure type.
   */
  legalStructure?: LegalStructureParameter;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type GetCountrySubdivisionParams = {
  /**
   * Two-letter ISO code for a country, such as US for USA.
   */
  countryCode?: CountryCodeParameter;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type ListWebhooksParams = {
  /**
   * Page Number
   */
  page?: PageNoParameter;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
};

export type GetFaqParams = {
  /**
   * Unique Client identifier
   */
  clientId?: ClientIdInQueryParameter;
  /**
   * Comma seperated tag values
   */
  tags?: string[];
};

export type GetCasesParams = {
  /**
   * Number of records per page.
   */
  limit?: CasesPageSizeParameter;
  /**
   * Page Number
   */
  page?: CasesPageNoParameter;
};

export type GetAllRecipientsParams = {
  /**
   * Unique Client identifier
   */
  clientId?: ClientIdInQueryParameter;
  /**
   * Recipient type to return
   */
  type?: RecipientType;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type GetDebitCardsParams = {
  /**
   * Current page number.
   */
  page?: number;
  /**
   * Number of records per page.
   */
  limit?: number;
};

export type DocumentsDetailsParams = {
  /**
   * The type of document. Can be terms and conditions or disclosure and consent documents.
   */
  type: DocumentTypeParameter;
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

export type GetAllRolesParams = {
  /**
   * Number of records per page.
   */
  limit?: UserPageSizeParameter;
  /**
   * Page Number
   */
  page?: UserPageNoParameter;
  /**
   * Role id
   */
  roleId?: UserRoleParameter;
};

export type GetAllUsersParams = {
  /**
 * Determines the fetch level.<br><br>
USER_STATUS: Fetches user status from identity provided<br><br>
PARTY: Fetches party information for user like names, address, phones etc.<br><br>
ROLES: Fetches user role information<br>
 */
  fetchLevel?: UserFetchLevelParameter;
  /**
   * Number of records per page.
   */
  limit?: UserPageSizeParameter;
  /**
   * Page Number
   */
  page?: UserPageNoParameter;
};

export type GetAllClientsParams = {
  /**
   * Number of records per page.
   */
  limit?: PageSizeParameter;
  /**
   * Page Number
   */
  page?: PageNoParameter;
};

/**
 * url encoded legalStructure type.
 */
export type LegalStructureParameter = string;

export type DocumentCategoryParameter =
  (typeof DocumentCategoryParameter)[keyof typeof DocumentCategoryParameter];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentCategoryParameter = {
  IDENTITY_VERIFICATION: 'IDENTITY_VERIFICATION',
} as const;

/**
 * Two-letter ISO code for a country, such as US for USA.
 */
export type CountryCodeParameter = string;

/**
 * Page Number
 */
export type CasesPageNoParameter = number;

/**
 * Number of records per page.
 */
export type CasesPageSizeParameter = number;

/**
 * Unique Client identifier
 */
export type ClientIdInQueryParameter = string;

export type DocumentTypeParameter =
  (typeof DocumentTypeParameter)[keyof typeof DocumentTypeParameter];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentTypeParameter = {
  TERMS_CONDITION: 'TERMS_CONDITION',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
} as const;

/**
 * Role id
 */
export type UserRoleParameter = string;

/**
 * Page Number
 */
export type UserPageNoParameter = number;

/**
 * Number of records per page.
 */
export type UserPageSizeParameter = number;

/**
 * Determines the fetch level.<br><br>
USER_STATUS: Fetches user status from identity provided<br><br>
PARTY: Fetches party information for user like names, address, phones etc.<br><br>
ROLES: Fetches user role information<br>
 */
export type UserFetchLevelParameter = FetchLevel[];

/**
 * Page Number
 */
export type PageNoParameter = number;

/**
 * Number of records per page.
 */
export type PageSizeParameter = number;

/**
 * Service Unavailable
 */
export type N503v2Response = ApiErrorV2;

/**
 * Internal Server Error
 */
export type N500v2Response = ApiErrorV2;

/**
 * Not Found
 */
export type N404v2Response = ApiErrorV2;

/**
 * Forbidden
 */
export type N403v2Response = ApiErrorV2;

/**
 * Unauthorized
 */
export type N401v2Response = ApiErrorV2;

/**
 * Bad Request
 */
export type N400v2Response = ApiErrorV2;

/**
 * No data found for the criteria specified
 */
export type User404Response = UserApiError;

/**
 * Bad Request
 */
export type User400Response = UserApiError;

/**
 * Service Unavailable - API Processing Error
 */
export type User503Response = UserApiError;

/**
 * Service not implemented
 */
export type User501Response = UserApiError;

/**
 * Internal Server Error - Generic Error
 */
export type User500Response = UserApiError;

/**
 * Forbidden
 */
export type User403Response = UserApiError;

/**
 * Unauthorized
 */
export type User401Response = UserApiError;

/**
 * Bad Request
 */
export type User400ClientIdResponse = UserApiError;

/**
 * Service Unavailable
 */
export type N503Response = ApiError;

/**
 * Internal Server Error
 */
export type N500Response = ApiError;

/**
 * Service Unavailable
 */
export type N404Response = ApiError;

/**
 * Forbidden
 */
export type N403Response = ApiError;

/**
 * Unauthorized
 */
export type N401Response = ApiError;

/**
 * Bad Request
 */
export type N400Response = ApiError;

export type WebhookCallbackEventResourceType =
  (typeof WebhookCallbackEventResourceType)[keyof typeof WebhookCallbackEventResourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookCallbackEventResourceType = {
  TRANSACTIONS: 'TRANSACTIONS',
  CLIENTS: 'CLIENTS',
  PARTIES: 'PARTIES',
  REMITTANCE: 'REMITTANCE',
  ACCOUNTS: 'ACCOUNTS',
  RECIPIENTS: 'RECIPIENTS',
} as const;

export type WebhookCallbackEventResourceObject =
  | TransactionCallbackEvent
  | ClientCallbackEvent
  | PartyCallbackEvent
  | RemittanceCallbackEvent
  | AccountCallbackEvent
  | RecipientsCallbackEvent;

export type WebhookCallbackEventEventType =
  (typeof WebhookCallbackEventEventType)[keyof typeof WebhookCallbackEventEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookCallbackEventEventType = {
  TRANSACTION_COMPLETED: 'TRANSACTION_COMPLETED',
  TRANSACTION_FAILED: 'TRANSACTION_FAILED',
  CLIENT_ONBOARDING: 'CLIENT_ONBOARDING',
  PARTY_NETWORK_SCREENING: 'PARTY_NETWORK_SCREENING',
  REMITTANCE_STATUS: 'REMITTANCE_STATUS',
  ACCOUNT_CREATED: 'ACCOUNT_CREATED',
  ACCOUNT_CLOSED: 'ACCOUNT_CLOSED',
  RECIPIENT_READY_FOR_VALIDATION: 'RECIPIENT_READY_FOR_VALIDATION',
  RECIPIENT_READY_FOR_VALIDATION_REMINDER:
    'RECIPIENT_READY_FOR_VALIDATION_REMINDER',
} as const;

export interface WebhookCallbackEvent {
  error?: ApiErrorV2;
  /** Unique identifier of the event */
  eventId: string;
  eventType: WebhookCallbackEventEventType;
  /** Json formatted string containing the notification details */
  resource: string;
  resourceObject?: WebhookCallbackEventResourceObject;
  resourceType: WebhookCallbackEventResourceType;
}

/**
 * Callback event type needs to send to notsub for correct status.
 */
export type RecipientNotificationStatus =
  (typeof RecipientNotificationStatus)[keyof typeof RecipientNotificationStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientNotificationStatus = {
  READY_FOR_VALIDATION: 'READY_FOR_VALIDATION',
  READY_FOR_VALIDATION_REMINDER: 'READY_FOR_VALIDATION_REMINDER',
} as const;

export interface RecipientsCallbackEvent {
  /** A unique recipient ID */
  id?: string;
  status?: RecipientNotificationStatus;
  type?: RecipientType;
}

/**
 * Category of the account
 */
export type AccountCallbackEventType =
  (typeof AccountCallbackEventType)[keyof typeof AccountCallbackEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCallbackEventType = {
  CLIENT_DDA: 'CLIENT_DDA',
  DDA: 'DDA',
  LIMITED_DDA: 'LIMITED_DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
  MANAGEMENT: 'MANAGEMENT',
  PROCESSING: 'PROCESSING',
} as const;

/**
 * Account state
 */
export type AccountCallbackEventState =
  (typeof AccountCallbackEventState)[keyof typeof AccountCallbackEventState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCallbackEventState = {
  OPEN: 'OPEN',
  PENDING_CLOSE: 'PENDING_CLOSE',
  CLOSED: 'CLOSED',
} as const;

export interface AccountCallbackEvent {
  /** A client's unique ID */
  clientId?: string;
  /** The date and time the account was created */
  createdAt?: string;
  /** Account identifier */
  id?: string;
  /** Account label */
  label?: string;
  paymentRoutingInformation?: PaymentRoutingInformation;
  /** Account state */
  state?: AccountCallbackEventState;
  /** Category of the account */
  type?: AccountCallbackEventType;
}

export type PaymentRoutingInformationRoutingInformation = {
  type: RoutingCode;
  /** Routing number */
  value: string;
};

export interface PaymentRoutingInformation {
  country?: CountryCode;
  /** Account number (PRN) */
  paymentRoutingNumber?: string;
  routingInformation?: PaymentRoutingInformationRoutingInformation;
}

export type RemittanceCallbackEventStatusType =
  (typeof RemittanceCallbackEventStatusType)[keyof typeof RemittanceCallbackEventStatusType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemittanceCallbackEventStatusType = {
  INITIAL_STATUS: 'INITIAL_STATUS',
  TRANSACTION_STATUS_REPORT: 'TRANSACTION_STATUS_REPORT',
} as const;

export interface RemittanceCallbackEvent {
  /** @minItems 1 */
  remittanceStatus?: StatusDetails[];
  statusType?: RemittanceCallbackEventStatusType;
  /** L0 response id */
  traceId?: string;
  /** to identify the transaction flow type */
  transactionType?: string;
  tsrGeneratedDateTime?: string;
}

/**
 * transaction status.
COMPLETED: Good To Pay
COMPLETED: Good To Withdraw
PENDING: Under Review
REJECTED: Cannot Be Processed
ROLLOVER: Rollover To Future Date
RETURNED: Returned
 */
export type StatusDetailsStatus =
  (typeof StatusDetailsStatus)[keyof typeof StatusDetailsStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusDetailsStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  ROLLOVER: 'ROLLOVER',
  RETURNED: 'RETURNED',
} as const;

export type StatusDetailsContextItem = {
  code?: string;
  /** additional information */
  message?: string;
};

/**
 * StatusDetails
 */
export interface StatusDetails {
  /**
   * reasons
   * @minItems 0
   * @maxItems 100
   */
  context?: StatusDetailsContextItem[];
  /** payment information Id */
  paymentId?: string;
  /** record number transaction array index */
  recordNumber?: string;
  /** organization end to end  id */
  remittanceId?: string;
  /** transaction status.
COMPLETED: Good To Pay
COMPLETED: Good To Withdraw
PENDING: Under Review
REJECTED: Cannot Be Processed
ROLLOVER: Rollover To Future Date
RETURNED: Returned */
  status?: StatusDetailsStatus;
}

/**
 * The client's status.
 */
export type PartyCallbackEventProfileStatus =
  (typeof PartyCallbackEventProfileStatus)[keyof typeof PartyCallbackEventProfileStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyCallbackEventProfileStatus = {
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface PartyCallbackEvent {
  /** Acquirer's External Merchant Id */
  acquirerMerchantId?: string;
  /** A party's unique ID */
  id?: string;
  /** The client's status. */
  profileStatus?: PartyCallbackEventProfileStatus;
}

/**
 * The client's status.
 */
export type ClientCallbackEventStatus =
  (typeof ClientCallbackEventStatus)[keyof typeof ClientCallbackEventStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClientCallbackEventStatus = {
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface ClientCallbackEvent {
  /** `true` if the client has outstanding items, otherwise `false`. */
  hasOutstandingInformation?: boolean;
  /** A client's unique ID */
  id?: string;
  /** The client's status. */
  status?: ClientCallbackEventStatus;
}

export interface TransactionCallbackEvent {
  /**
   * Transaction amount
   */
  amount?: string;
  /** The c2 client id */
  clientId?: string;
  /** The account id of the transaction receiver */
  creditorAccountId?: string;
  /** Payment currency */
  currency?: string;
  /** The account Id of the transaction originator, this could be of type (VTA - Virtual Account) or (DDA - Physical Account) */
  debtorAccountId?: string;
  /** The id of the transaction */
  id?: string;
  /**
   * The account balance. If the value is negative, then the account is overdrawn.
   * @minLength 1
   * @maxLength 40
   * @pattern ^[-+]?\d+(\.\d+)?$
   */
  ledgerBalance?: string;
  /** In case of RETURN transaction, this field has information about the original transaction. For other transactions it has the Memorandum. */
  memo?: string;
  /** ID to show the connection between this transaction and its originating transaction. */
  originatingId?: string;
  /** In case of RETURN transaction, this field refers to the original 'ACH' transaction, for which a RETURN has been initiated. */
  originatingTransactionType?: string;
  /** ISO date format - yyyy-MM-dd */
  paymentDate?: string;
  /** Recipient Id of the transaction receiver */
  recipientId?: string;
  /** The final status of the transaction */
  status?: string;
  /** Transaction reference id provided by client */
  transactionReferenceId?: string;
  /** The type of transaction network such as ACH, RTP, etc ... */
  type?: string;
}

export interface PaymentIntentRequest {
  /** @minimum 0.01 */
  amount: number;
  /** Transaction currency
   */
  currency: string;
  /**
   * ID of the account to make the payment from.
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  debtorAccountId?: string;
  /** ISO date format - yyyy-MM-dd. If no date is provided, value will be set to 10 days from the current date. */
  expirationDate?: string;
  /** Recipient ID */
  recipientId: string;
}

export interface PaymentIntents {
  /**
   * List of payment intents meeting the request criteria
   * @minItems 0
   */
  items: PaymentIntent[];
  metadata: PageMetaData;
}

/**
 * Payment intent status
 */
export type PaymentIntentStatus =
  (typeof PaymentIntentStatus)[keyof typeof PaymentIntentStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentIntentStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED',
  SCHEDULED: 'SCHEDULED',
} as const;

export interface UpdatePaymentIntentRequest {
  status?: PaymentIntentStatus;
}

/**
 * Payment intent status
 */
export type PaymentIntentType =
  (typeof PaymentIntentType)[keyof typeof PaymentIntentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentIntentType = {
  PAYABLE: 'PAYABLE',
} as const;

export interface PaymentIntent {
  /** @minimum 0.01 */
  amount?: number;
  /** Generated balance hold Id of payable */
  balanceHoldId?: string;
  /** Date the payment intent was created. */
  createdAt?: string;
  /** Creditor's email */
  creditorEmail?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder?s business or their first and last name. */
  creditorName?: string;
  /** The currency of the check, in three-character ISO currency code.
   */
  currency?: string;
  /** ID of the account to make the payment from. */
  debtorAccountId?: string;
  /** The last 4 digits of the debtor account number. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccountNumber?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder?s business or their first and last name. */
  debtorName?: string;
  /** ISO date format - yyyy-MM-dd. If no date provided, value should be set to 30 days from the current date. */
  expirationDate?: string;
  /** Payable ID */
  id?: string;
  /** Recipient ID */
  recipientId?: string;
  status?: PaymentIntentStatus;
  /** Generated transaction Id of payable */
  transactionId?: string;
  type?: PaymentIntentType;
}

/**
 * The type of billing the client is currently using.
 */
export type BillingClientDetailsResponseType =
  (typeof BillingClientDetailsResponseType)[keyof typeof BillingClientDetailsResponseType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseType = {
  SUBSCRIPTION: 'SUBSCRIPTION',
  PAY_AS_YOU_GO: 'PAY_AS_YOU_GO',
} as const;

/**
 * The period when the client would be billed if they are on a subscription.
 */
export type BillingClientDetailsResponsePeriodType =
  (typeof BillingClientDetailsResponsePeriodType)[keyof typeof BillingClientDetailsResponsePeriodType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponsePeriodType = {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
} as const;

/**
 * The charge currency.
 */
export type BillingClientDetailsResponseCurrency =
  (typeof BillingClientDetailsResponseCurrency)[keyof typeof BillingClientDetailsResponseCurrency];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseCurrency = {
  USD: 'USD',
} as const;

/**
 * The month in which the client will be billed if they are on an yearly subscription.
 */
export type BillingClientDetailsResponseBillingMonth =
  (typeof BillingClientDetailsResponseBillingMonth)[keyof typeof BillingClientDetailsResponseBillingMonth];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseBillingMonth = {
  JANUARY: 'JANUARY',
  FEBRUARY: 'FEBRUARY',
  MARCH: 'MARCH',
  APRIL: 'APRIL',
  MAY: 'MAY',
  JUNE: 'JUNE',
  JULY: 'JULY',
  AUGUST: 'AUGUST',
  SEPTEMBER: 'SEPTEMBER',
  OCTOBER: 'OCTOBER',
  NOVEMBER: 'NOVEMBER',
  DECEMBER: 'DECEMBER',
} as const;

/**
 * How the fee is going to be calculated on a pay as you go billing type or if the client has excedeed their allwance on a subscription.
 */
export type BillingEventCalculationType =
  (typeof BillingEventCalculationType)[keyof typeof BillingEventCalculationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventCalculationType = {
  PERCENTAGE: 'PERCENTAGE',
  FLAT_AMOUNT: 'FLAT_AMOUNT',
} as const;

/**
 * The billing product type.
 */
export type BillingEventBillingEventType =
  (typeof BillingEventBillingEventType)[keyof typeof BillingEventBillingEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventBillingEventType = {
  TRANSACTION: 'TRANSACTION',
} as const;

/**
 * The billing product sub-type.
 */
export type BillingEventBillingEventSubType =
  (typeof BillingEventBillingEventSubType)[keyof typeof BillingEventBillingEventSubType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventBillingEventSubType = {
  ACH_PAYOUT: 'ACH_PAYOUT',
  RTP_PAYOUT: 'RTP_PAYOUT',
  WIRE_PAYOUT: 'WIRE_PAYOUT',
} as const;

export interface BillingEvent {
  /**
   * Allowance of the particular product per billing cycle if they are on a subscription.
   * @minimum 0
   */
  allowance?: number;
  /** The billing product sub-type. */
  billingEventSubType: BillingEventBillingEventSubType;
  /** The billing product type. */
  billingEventType: BillingEventBillingEventType;
  /** How the fee is going to be calculated on a pay as you go billing type or if the client has excedeed their allwance on a subscription. */
  calculationType: BillingEventCalculationType;
  /** Date when configuration comes into effect */
  effectiveDateFrom: string;
  /** Date when configuration ceases being in effect */
  effectiveDateTo: string;
  /** Rate to be used as billing fee - required for FLAT_RATE calculation type. Must be a non-negative decimal value */
  flatCharge?: number;
  /** Maximum fee to be applied if calculated billing fee is higher. Must be a non-negative decimal value - required for PERCENTAGE calculation type */
  maxCharge?: number;
  /** Minimum fee to be applied if calculated billing fee is lower. Must be a non-negative decimal value - required for PERCENTAGE calculation type */
  minCharge?: number;
  /** Percentage proportion for use in calculating billing fee - required for PERCENTAGE calculation type. Must be a positive decimal value between 0 to 1 (inclusive) */
  percentageValue?: number;
  /**
   * The amount of allwance used by the client so far if they are on a subscription.
   * @minimum 0
   */
  usage?: number;
}

export interface BillingClientDetailsResponse {
  /**
   * The day the client would be billed on if they are on a subcription.
   * @minimum 1
   * @maximum 31
   */
  billingDay?: number;
  /** The month in which the client will be billed if they are on an yearly subscription. */
  billingMonth?: BillingClientDetailsResponseBillingMonth;
  /**
   * The charge currency.
   */
  currency: BillingClientDetailsResponseCurrency;
  /** @minItems 0 */
  items: BillingEvent[];
  /** The date that the client will next be billed on if they are on a subscription. */
  nextBillingDate?: string;
  /** The period when the client would be billed if they are on a subscription. */
  periodType?: BillingClientDetailsResponsePeriodType;
  /**
   * The amount the client would be charged on the billing day if they are on a subscription.
   * @minimum 0.01
   */
  subscriptionCharge?: number;
  /** The name of the subscription package if the client is on a subscription. */
  subscriptionName?: string;
  /**
   * The type of billing the client is currently using.
   */
  type: BillingClientDetailsResponseType;
}

/**
 * An optional field present if a balance hold comes from a card transaction.
 */
export interface CardTransactionAttributes {
  /** The authorization code for the balance hold, returned to the merchant. */
  authCode: string;
  /** The last 4 digits of the card that was used to initiate the balance hold. */
  cardLast4: string;
  /** The ID of the card that was used to initiate the balance hold. */
  id: string;
  /** The name of the merchant where the balance hold was initiated. */
  merchantName: string;
}

export interface BalanceHoldGetResponse {
  /** The amount that was initially authorized. This could be different than the requested amount if partial authorizations take place. */
  authorizedAmount: number;
  /** The date and time in UTC at which the balance hold was created. */
  createdAt: string;
  /** The currency code used for the balance hold. */
  currency: string;
  /** The VAID of the account the balance hold is placed on. */
  debtorAccountId?: string;
  /** The PRN of the account the balance hold is placed on. */
  debtorAccountNumber: string;
  /** The date and time in UTC at which the balance hold will expire. */
  expirationDateTime: string;
  /** The full balance hold id. */
  id: string;
  /** The amount that is currently being held. */
  pendingAmount: number;
  /** The amount that was initially requested. */
  requestedAmount: number;
  /** The status of the balance hold. */
  status: string;
  typeSpecificAttributes: CardTransactionAttributes;
  /** The date and time in UTC at which any update was made to the balance hold. */
  updatedAt: string;
}

export interface ListBalanceHoldGetResponse {
  /**
   * List of all holds on an account balance.
   * @minItems 0
   */
  items: BalanceHoldGetResponse[];
  metadata: PageMetaData;
}

/**
 * Balance type: ITAV (interim available balance) or ITBD (interim booked balance)
 */
export type AccountBalanceDtoTypeCode =
  (typeof AccountBalanceDtoTypeCode)[keyof typeof AccountBalanceDtoTypeCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountBalanceDtoTypeCode = {
  ITAV: 'ITAV',
  ITBD: 'ITBD',
} as const;

export interface AccountBalanceDto {
  /** Balance amount */
  amount: number;
  /** Balance type: ITAV (interim available balance) or ITBD (interim booked balance) */
  typeCode: AccountBalanceDtoTypeCode;
}

export interface AccountBalanceResponse {
  /**
   * List of account balances of type ITAV (interim available balance) or ITBD (interim booked balance)
   * @minItems 0
   */
  balanceTypes: AccountBalanceDto[];
  /** Balance currency */
  currency: string;
  /** Balance date in ISO date format - yyyy-MM-dd */
  date: string;
  /** Account identifier */
  id: string;
}

/**
 * Payment routing status. Identifies whether the account is active, which means it has been used within the last 13 months. An account with the status INACTIVE is changed to ACTIVE as soon as a transaction is made on the account.
 */
export type PaymentRoutingStatus =
  (typeof PaymentRoutingStatus)[keyof typeof PaymentRoutingStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRoutingStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

export interface PaymentRoutingInformationDtoWithStatus {
  /** Account number (PRN) */
  accountNumber: string;
  country: CountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: RoutingInformationDto[];
  status: PaymentRoutingStatus;
}

export interface AccountResponseWithStatus {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** Closure Reason */
  closureReason?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: PaymentRoutingInformationDtoWithStatus;
  state: AccountState;
}

/**
 * Category of account in create requests
 */
export type AccountCategoryReq =
  (typeof AccountCategoryReq)[keyof typeof AccountCategoryReq];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCategoryReq = {
  LIMITED_DDA: 'LIMITED_DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
} as const;

export interface CreateAccountRequest {
  category?: AccountCategoryReq;
  /**
   * Client identifier
   * @pattern ^\d{10}$
   */
  clientId?: string;
  /** Account label: MAIN, PROJECT, TAXES or RAINY_DAY */
  label?: string;
}

/**
 * Category of account
 */
export type AccountCategory =
  (typeof AccountCategory)[keyof typeof AccountCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCategory = {
  CLIENT_DDA: 'CLIENT_DDA',
  CLIENT_OFFSET: 'CLIENT_OFFSET',
  DDA: 'DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
  LIMITED_DDA: 'LIMITED_DDA',
  MANAGEMENT: 'MANAGEMENT',
  PROCESSING: 'PROCESSING',
  PROCESSING_OFFSET: 'PROCESSING_OFFSET',
} as const;

export interface AccountResponse {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: PaymentRoutingInformationDto;
  state: AccountState;
}

export interface ListAccountsResponse {
  /**
   * List of accounts for a specific client
   * @minItems 0
   */
  items: AccountResponse[];
  metadata: PageMetaData;
}

/**
 * Routing codes supported (currently only ABA is supported)
 */
export type RoutingCode = (typeof RoutingCode)[keyof typeof RoutingCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingCode = {
  ABA: 'ABA',
} as const;

export interface RoutingInformationDto {
  type: RoutingCode;
  /** Routing number */
  value: string;
}

export interface PaymentRoutingInformationDto {
  /** Account number (PRN) */
  accountNumber: string;
  country: CountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: RoutingInformationDto[];
}

/**
 * Account State
 */
export type AccountState = (typeof AccountState)[keyof typeof AccountState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountState = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  PENDING_CLOSE: 'PENDING_CLOSE',
} as const;

export type TransactionGetResponseAllOf = {
  debitCardDetails?: DebitCardDetails;
  status?: TransactionStatus;
  transactionType?: TransactionType;
};

export type TransactionGetResponse = TransactionGetResponseDetails &
  TransactionGetResponseAllOf;

/**
 * The transaction type of the originating transaction that incurred a fee. This is only available for fee transactions. * ACH_PAYOUT - the original transaction was a payout made by ACH payment route. * RTP_PAYOUT - the original transaction was a payout made by ACH payment route. * WIRE_PAYOUT - the original transaction was a payout made by WIRE payment route. * DEBIT_CARD_REQUEST - the original transaction was a debit card request. * FEE - the original transaction was a fee that was reversed.
 */
export type OriginatingTransactionType =
  (typeof OriginatingTransactionType)[keyof typeof OriginatingTransactionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OriginatingTransactionType = {
  ACH_PAYOUT: 'ACH_PAYOUT',
  RTP_PAYOUT: 'RTP_PAYOUT',
  WIRE_PAYOUT: 'WIRE_PAYOUT',
  DEBIT_CARD_REQUEST: 'DEBIT_CARD_REQUEST',
  FEE: 'FEE',
} as const;

/**
 * The type of the fee transaction. Use this to differentiate between the fee transactions that were charged and those that were reversed. * CHARGE - the fee that was incurred as a result of a transaction. * REVERSAL - the fee was incurred and then voided on a transaction.
 */
export type FeeType = (typeof FeeType)[keyof typeof FeeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeeType = {
  CHARGE: 'CHARGE',
  REVERSAL: 'REVERSAL',
} as const;

export interface TransactionGetResponseDetails {
  accountingType?: AccountingType;
  /** Transaction value */
  amount?: number;
  /** The date and time the transaction was created. */
  creationTimestamp?: string;
  /** The last 4 digits of the creditor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  creditorAccount?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder?s business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** The last 4 digits of the debtor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccount?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder?s business or their first and last name. */
  debtorName?: string;
  feeType?: FeeType;
  /** Transaction ID */
  id?: string;
  /** Memorandum */
  memo?: string;
  /** The transactionId of a transaction which incurred a fee. Use this ID to show the connection between a fee transaction and its originating transaction. This is only available for fee transactions. */
  originatingTransactionId?: string;
  originatingTransactionType?: OriginatingTransactionType;
  /** Date of transaction */
  paymentDate?: string;
  paymentRoute?: PaymentRoute;
  /** The reason a transaction was REJECTED or RETURNED. This is populated only for transactions with 'REJECTED' status. For all other transactions, the value is 'null'. */
  rejectedReason?: string;
}

export interface MerchantAddress {
  addressLine1?: string;
  city?: string;
  countryCode?: string;
  state?: string;
  zip?: string;
}

export interface Merchant {
  address?: MerchantAddress;
  name?: string;
}

export interface DebitCardDetails {
  cardLast4?: string;
  cardPaymentRoutingNumber?: string;
  cardSerialNumber?: string;
  cardTransactionType?: string;
  isa?: string;
  merchant?: Merchant;
  messageType?: string;
  surcharge?: number;
}

export interface TransactionResponse {
  accountId?: string;
  accountNumber?: string;
  amount?: number;
  c2ProfileId?: string;
  currency?: string;
  debitCardDetails?: DebitCardDetails;
  id?: string;
  memo?: string;
  /** ISO date format - yyyy-MM-dd */
  paymentDate?: string;
  recipient?: TransactionRecipientDetails;
  status?: TransactionStatus;
  type?: PaymentType;
}

/**
 * Payment currency - currently supported: USD
 */
export type PostTransactionRequestCurrency =
  (typeof PostTransactionRequestCurrency)[keyof typeof PostTransactionRequestCurrency];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostTransactionRequestCurrency = {
  USD: 'USD',
} as const;

export interface PostTransactionRequest {
  /**
   * @minimum 0.01
   */
  amount: number;
  /**
   * Payment currency - currently supported: USD
   */
  currency: PostTransactionRequestCurrency;
  /**
   * Memorandum
   * @minLength 1
   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  memo?: string;
  /**
   * ID of the account to make the payment from
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  originatingAccount: string;
  /**
   * ISO date format - yyyy-MM-dd
   */
  paymentDate: string;
  recipient?: TransactionRecipientDetails;
  /** Payment recipient Id, either recipient or recipient id must be provided */
  recipientId?: string;
  type: PaymentType;
}

/**
 * First line of the recipient's postal address.
For payment types ACH, WIRE and RTP routingCodeType, routingNumber and countryCode are required.
For payment type of ACH account type is required.

 */
export interface TransactionRecipientAccount {
  countryCode?: CountryCode;
  number: AccountNumber;
  routingCodeType?: RoutingCodeType;
  routingNumber?: RoutingNumber;
  type?: AccountType;
}

/**
 * Recipient's postal address
Mandatory for payment types WIRE, RTP

 */
export interface TransactionRecipientAddress {
  /**
   * First line of the recipient's postal address
For payment type WIRE addressLine1 cannot exceed 35 characters
For payment type RTP addressLine1 cannot exceed 70 characters

   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine1: string;
  /**
   * Second line of the recipient's postal address
   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine2?: string;
  /**
   * Third line of the recipient's postal address
   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine3?: string;
  /**
   * City of the recipient's postal address
For payment type WIRE city and state combined cannot exceed 35 characters

   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  city: string;
  countryCode: CountryCode;
  /**
   * State of the recipient's postal address
For payment type WIRE city and state combined cannot exceed 35 characters

   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  state: string;
  /**
   * Zip code of the recipient's postal address
   * @minLength 1
   * @maxLength 16
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  zip: string;
}

export interface TransactionRecipientPartyDetail {
  address?: TransactionRecipientAddress;
  /**
   * Recipient company name
Mandatory for recipient type ORGANIZATION
For payment type WIRE business name cannot exceed 35 characters

   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  businessName?: string;
  /** @minItems 0 */
  contacts?: RecipientContact[];
  /**
   * Recipient's first name
Mandatory for recipient type INDIVIDUAL
For payment type WIRE firstName and lastName combined cannot exceed 35 characters

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  firstName?: string;
  /**
   * Recipient's last name
Mandatory for recipient type INDIVIDUAL
For payment type WIRE firstName and lastName combined cannot exceed 35 characters

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  lastName?: string;
  type?: PartyType;
}

/**
 * Payment recipient, either recipient or recipient id must be provided
 */
export interface TransactionRecipientDetails {
  account: TransactionRecipientAccount;
  partyDetails?: TransactionRecipientPartyDetail;
}

/**
 * Payment method - ACH, RTP, WIRE, ACH, TRANSFER. Only ACH (for payouts) and TRANSFER (for payments between embedded accounts) are used in Embedded Payments transactions.
 */
export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentType = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
  TRANSFER: 'TRANSFER',
} as const;

export interface ListTransactionsSearchResponse {
  /**
   * List of transactions meeting the request criteria
   * @minItems 0
   */
  items: TransactionsSearchResponse[];
  metadata: PageMetaData;
}

/**
 * The method by which the payment was made - RTP, WIRE, ACH
 */
export type PaymentRoute = (typeof PaymentRoute)[keyof typeof PaymentRoute];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRoute = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
} as const;

/**
 * Accounting type (Credit (CR) / Debit (DR)) for transaction
 */
export type AccountingType =
  (typeof AccountingType)[keyof typeof AccountingType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountingType = {
  DR: 'DR',
  CR: 'CR',
} as const;

/**
 * Defines the transaction according to specific types. For example, whether money has been paid into or out of the account.
 */
export type TransactionType =
  (typeof TransactionType)[keyof typeof TransactionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionType = {
  PAYIN: 'PAYIN',
  PAYTO: 'PAYTO',
  PAYINTO: 'PAYINTO',
  TRANSFER: 'TRANSFER',
  PAYOUT: 'PAYOUT',
  PAYIN_REVERSAL: 'PAYIN_REVERSAL',
  PAYOUT_REVERSAL: 'PAYOUT_REVERSAL',
  MISC_CREDIT: 'MISC_CREDIT',
  MISC_DEBIT: 'MISC_DEBIT',
  UNDEFINED: 'UNDEFINED',
  PAYINTORECEIPT: 'PAYINTORECEIPT',
  PAYOUTCOLLECTION: 'PAYOUTCOLLECTION',
  PAYINTOCOLLECTION: 'PAYINTOCOLLECTION',
  PAYINTO_RETURN: 'PAYINTO_RETURN',
  PAYOUTCOLLECTION_RETURN: 'PAYOUTCOLLECTION_RETURN',
  PAYINTOCOLLECTION_RETURN: 'PAYINTOCOLLECTION_RETURN',
  RETURN: 'RETURN',
  CARD: 'CARD',
  FEE: 'FEE',
  BOOKTRANSFER: 'BOOKTRANSFER',
} as const;

/**
 * The current status of the transaction as it is processed:
 * `PENDING` - The transaction is still being processed.
 * `CANCELED` - The transaction has been canceled.
 * `COMPLETED` - The transaction has been completed.
 * `COMPLETED_WITH_EXCEPTIONS` - The transaction has completed, but not all of the requested criteria has been fulfilled.
 * `REJECTED` - The transaction has been rejected and will not be completed.
 * `RETURNED` - The payment rail has been unable to complete the payment specified recipient. The payment has been returned to the originator. 
 * `PARTIALLY_COMPLETED` - Not all transactions in the batch have been completed. 
 * `UNDEFINED` - The status of this transaction cannot be found.

 */
export type TransactionStatus =
  (typeof TransactionStatus)[keyof typeof TransactionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatus = {
  PENDING: 'PENDING',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED',
  COMPLETED_WITH_EXCEPTIONS: 'COMPLETED_WITH_EXCEPTIONS',
  COMPLETED_NOT_IN_TARGET_WALLET: 'COMPLETED_NOT_IN_TARGET_WALLET',
  REJECTED: 'REJECTED',
  RETURNED: 'RETURNED',
  PARTIALLY_COMPLETED: 'PARTIALLY_COMPLETED',
  UNDEFINED: 'UNDEFINED',
} as const;

export interface TransactionsSearchResponse {
  accountingType?: AccountingType;
  /** Transaction amount */
  amount?: string;
  /** Transaction creation date */
  createdDate?: string;
  /** The date and time the transaction was created. */
  creationTimestamp?: string;
  /** The last 4 digits of the creditor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  creditorAccount?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder?s business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** The last 4 digits of the debtor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  debtorAccount?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder?s business or their first and last name. */
  debtorName?: string;
  /** The time and date when the ledger balance was updated. */
  effectiveDate?: string;
  /** The ledger balance shows the total of all settled transactions at the time the request is made. Transactions which are in a pending state and transactions of type hold are excluded from this balance. The ledger balance is updated only when a transaction is settled. */
  ledgerBalance?: number;
  paymentRoute?: PaymentRoute;
  /** A measure of how many times an account has been updated by a new transaction. The posting version is incremented by 1 whenever there's a an event on the account. It can be used to track the order in which transactions have occurred, so you can present the user with the most recent transactions first. */
  postingVersion?: number;
  status?: TransactionStatus;
  /** Unique identifier of a transaction */
  transactionId?: string;
  transactionType?: TransactionType;
}

/**
 * The statuses of the transaction that the client is allowed to search by.
 */
export type RequestTransactionStatus =
  (typeof RequestTransactionStatus)[keyof typeof RequestTransactionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestTransactionStatus = {
  PENDING: 'PENDING',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED',
  COMPLETED_WITH_EXCEPTIONS: 'COMPLETED_WITH_EXCEPTIONS',
  REJECTED: 'REJECTED',
  RETURNED: 'RETURNED',
  PARTIALLY_COMPLETED: 'PARTIALLY_COMPLETED',
  UNDEFINED: 'UNDEFINED',
} as const;

/**
 * The types of transaction that the client is allowed to search by.
 */
export type RequestTransactionType =
  (typeof RequestTransactionType)[keyof typeof RequestTransactionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestTransactionType = {
  PAYIN: 'PAYIN',
  PAYOUT: 'PAYOUT',
  PAYTO: 'PAYTO',
  PAYINTOCOLLECTION: 'PAYINTOCOLLECTION',
  TRANSFER: 'TRANSFER',
  REVERSAL: 'REVERSAL',
  UNDEFINED: 'UNDEFINED',
  RETURN: 'RETURN',
  CARD: 'CARD',
  FEE: 'FEE',
} as const;

export interface MetaData {
  /** Payment routing number of the account related to the statement. */
  accountNumber?: string;
  /** Statement creation date and time. */
  createdDate?: string;
  month?: string;
  year?: string;
}

export interface Statement {
  /** Statement identifier used to retrieve statement document (Base64 encoded). */
  id?: string;
  metaData?: MetaData;
}

export interface StatementsResponse {
  /** @minItems 0 */
  statements?: Statement[];
}

export interface PartyTypesResponse {
  /**
   * The list of available partyRoles e.g.   "Individual", "Organization"
   * @minItems 0
   */
  partyTypes?: string[];
}

export interface NatureOfOwnershipsResponse {
  /**
   * The list of available partyRoles e.g.  "Direct", "Indirect"
   * @minItems 0
   */
  natureOfOwnerships?: string[];
}

export interface AddressTypesResponse {
  /**
   * The list of available partyRoles e.g. "Principle place of business", "Primary Residence"
   * @minItems 0
   */
  addressTypes?: string[];
}

export interface PartyRolesResponse {
  /**
   * The list of available partyRoles e.g. OWNER, DECISION_MAKER, CONTROLLER
   * @minItems 0
   */
  partyRoles?: string[];
}

export interface JobTitlesResponse {
  /**
   * The list of job titles
   * @minItems 0
   */
  jobTitles?: string[];
}

export interface BusinessTypesResponse {
  /**
   * The list of business types.
   * @minItems 0
   */
  businessTypes?: string[];
}

export interface ProductInformation {
  code?: string;
  name?: string;
}

export interface ProductResponse {
  /** @minItems 0 */
  products?: ProductInformation[];
}

export interface IndustryCategory {
  industryCategory?: string;
  /** @minItems 0 */
  industryTypes?: string[];
}

/**
 * @minItems 0
 */
export type IndustryCategories = IndustryCategory[];

export interface IndustryCategoriesResponse {
  items?: IndustryCategories;
  metadata?: PageMetaData;
}

export interface IdentificationInformation {
  length?: number;
  name?: string;
  type?: string;
}

export interface IdentificationTypeResponse {
  /** @minItems 0 */
  identificationTypes?: IdentificationInformation[];
}

export interface DocumentTypesResponse {
  items?: DocumentTypesResponses;
  metadata?: PageMetaData;
}

export interface DocumentTypeItem {
  /**
   * @minLength 1
   * @maxLength 200
   * @pattern ^.*\S.*$
   */
  id?: string;
  /**
   * @minLength 1
   * @maxLength 200
   * @pattern ^.*\S.*$
   */
  label?: string;
  /** @minItems 0 */
  legalStructures?: string[];
}

export type DocumentTypesOrganization = {
  /**
   * @minItems 0
   * @maxItems 25
   */
  primary?: DocumentTypeItem[];
  /**
   * @minItems 0
   * @maxItems 25
   */
  secondary?: DocumentTypeItem[];
};

export type DocumentTypesIndividual = {
  /**
   * @minItems 0
   * @maxItems 25
   */
  primary?: DocumentTypeItem[];
  /**
   * @minItems 0
   * @maxItems 25
   */
  secondary?: DocumentTypeItem[];
};

export interface DocumentTypes {
  category?: string;
  individual?: DocumentTypesIndividual;
  organization?: DocumentTypesOrganization;
}

export interface DocumentTypeResponse {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  country?: string;
  documentTypes?: DocumentTypes;
}

/**
 * @minItems 0
 */
export type DocumentTypesResponses = DocumentTypeResponse[];

export interface LegalStructureResponse {
  /**
   * The list of client legal structures
   * @minItems 0
   */
  legalStructures?: string[];
}

export interface SubdivisionInformation {
  /**
   * @minLength 1
   * @maxLength 3
   * @pattern ^[0-9A-Z]{1,3}$
   */
  code?: string;
  name?: string;
}

export interface CountrySubdivision {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  countryCode?: string;
  /** @minItems 0 */
  subDivision?: SubdivisionInformation[];
}

/**
 * @minItems 0
 * @maxItems 100
 */
export type CountrySubdivisionArray = CountrySubdivision[];

export interface CountrySubdivisionResponse {
  items?: CountrySubdivisionArray;
  metadata?: PageMetaData;
}

export interface CountryInformation {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  code?: string;
  name?: string;
}

export interface CountriesResponse {
  /** @minItems 0 */
  countries?: CountryInformation[];
}

/**
 * Allowed status - ACTIVE or INACTIVE
 */
export type WebhookUpdateRequestStatus =
  (typeof WebhookUpdateRequestStatus)[keyof typeof WebhookUpdateRequestStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookUpdateRequestStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

/**
 * Update a webhook - add, remove subscriptions or change the status of your webhook
 */
export interface WebhookUpdateRequest {
  /** Allowed status - ACTIVE or INACTIVE */
  status: WebhookUpdateRequestStatus;
  /** @minItems 0 */
  subscriptions: Subscription[];
}

/**
 * Create a webhook
 */
export interface WebhookRequest {
  /**
   * List of subscription items called subscription details
   * @minItems 0
   * @maxItems 100
   */
  subscriptions: Subscription[];
}

/**
 * The status of this webhook.
 */
export type WebhookResponseStatus =
  (typeof WebhookResponseStatus)[keyof typeof WebhookResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookResponseStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

/**
 * The event types to be notified of.
 */
export type SubscriptionEventType =
  (typeof SubscriptionEventType)[keyof typeof SubscriptionEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionEventType = {
  TRANSACTION_COMPLETED: 'TRANSACTION_COMPLETED',
  TRANSACTION_FAILED: 'TRANSACTION_FAILED',
  CLIENT_ONBOARDING: 'CLIENT_ONBOARDING',
  REMITTANCE_STATUS: 'REMITTANCE_STATUS',
  PARTY_NETWORK_SCREENING: 'PARTY_NETWORK_SCREENING',
  CLIENT_ONBOARDING_COMPLETED: 'CLIENT_ONBOARDING_COMPLETED',
  CLIENT_OFFBOARDING_COMPLETED: 'CLIENT_OFFBOARDING_COMPLETED',
  CLIENT_ADD_INFO_REQUESTED: 'CLIENT_ADD_INFO_REQUESTED',
  CLIENT_ADD_INFO_VERIFIED: 'CLIENT_ADD_INFO_VERIFIED',
  CLIENT_ADD_INFO_FAILED: 'CLIENT_ADD_INFO_FAILED',
  ACCOUNT_CREATED: 'ACCOUNT_CREATED',
  ACCOUNT_CLOSED: 'ACCOUNT_CLOSED',
  RECIPIENT_READY_FOR_VALIDATION: 'RECIPIENT_READY_FOR_VALIDATION',
  RECIPIENT_READY_FOR_VALIDATION_REMINDER:
    'RECIPIENT_READY_FOR_VALIDATION_REMINDER',
} as const;

/**
 * The webhooks you are subscribed to. Each subscription contains events about which you are notified via HTTPS request to your pre-configured server URL.
 */
export interface Subscription {
  /** The event types to be notified of. */
  eventType: SubscriptionEventType;
}

export interface WebhookResponse {
  /** The date and time the webhook was created */
  createdAt: string;
  /** The unique identifier of this webhook */
  id: string;
  /** The status of this webhook. */
  status: WebhookResponseStatus;
  /**
   * @minItems 0
   * @maxItems 100
   */
  subscriptions: Subscription[];
  /** The date and time the webhook was updated */
  updatedAt: string;
}

/**
 * FAQ Type enum
 */
export type FaqType = (typeof FaqType)[keyof typeof FaqType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FaqType = {
  C1_General: 'C1 General',
  C1_Specific: 'C1 Specific',
} as const;

export interface Faq {
  /** Answer */
  answer: string;
  /** Question */
  question: string;
  /**
   * FAQ Tags
   * @minItems 0
   */
  tags: string[];
  /** FAQ Type enum */
  type: FaqType;
}

/**
 * List of FAQ Questions and Answers
 */
export interface FAQResponse {
  /**
   * Object of a FAQ
   * @minItems 0
   */
  faqs: Faq[];
}

/**
 * The status you want the case to have as a result of this request. To close a case, use CLOSED. To reopen a case, use REOPEN.
 */
export type CaseUpdateRequestStatus =
  (typeof CaseUpdateRequestStatus)[keyof typeof CaseUpdateRequestStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseUpdateRequestStatus = {
  CLOSED: 'CLOSED',
  REOPEN: 'REOPEN',
} as const;

export interface CaseUpdateRequest {
  /**
   * A comment on the case. Can be the reason for updating the status of a case.
   * @minLength 1
   * @maxLength 3000
   * @pattern ^(?!\s*$)[\s\S]*$
   */
  comment: string;
  /** The status you want the case to have as a result of this request. To close a case, use CLOSED. To reopen a case, use REOPEN. */
  status?: CaseUpdateRequestStatus;
}

/**
 * Case category
 */
export type CaseDetailsType =
  (typeof CaseDetailsType)[keyof typeof CaseDetailsType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseDetailsType = {
  ACCOUNT: 'ACCOUNT',
  CARD: 'CARD',
  ENROLLMENT_OR_SIGNUP: 'ENROLLMENT_OR_SIGNUP',
  OTHER: 'OTHER',
  PROFILE: 'PROFILE',
  STATEMENT: 'STATEMENT',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  TRANSACTION: 'TRANSACTION',
} as const;

/**
 * Current status on case.
 */
export type CaseDetailsStatus =
  (typeof CaseDetailsStatus)[keyof typeof CaseDetailsStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseDetailsStatus = {
  CLOSED: 'CLOSED',
  REOPEN: 'REOPEN',
  OPEN: 'OPEN',
} as const;

/**
 * How the case was originally reported. This can be by form, phone, or email.
 */
export type CaseDetailsOrigin =
  (typeof CaseDetailsOrigin)[keyof typeof CaseDetailsOrigin];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseDetailsOrigin = {
  PHONE: 'PHONE',
  FORM: 'FORM',
  EMAIL: 'EMAIL',
} as const;

export interface CaseDetails {
  /** @minItems 0 */
  comments?: CommentDetails[];
  createdBy: ContactDetails;
  /** Date/Time the case was opened */
  createdDate: string;
  /** More detailed description of the case. */
  description: string;
  /** Case identifier. */
  id: string;
  /** How the case was originally reported. This can be by form, phone, or email. */
  origin: CaseDetailsOrigin;
  /** Current status on case. */
  status: CaseDetailsStatus;
  /** Subject of a case. */
  subject: string;
  /** Case category */
  type: CaseDetailsType;
  /** Date/Time the case was closed */
  updatedDate: string;
}

export interface CaseCreateResponse {
  /** Date/Time the case was opened */
  createdDate: string;
  /** Case identifier */
  id: string;
}

/**
 * Case category
 */
export type CaseCreateRequestType =
  (typeof CaseCreateRequestType)[keyof typeof CaseCreateRequestType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseCreateRequestType = {
  ACCOUNT: 'ACCOUNT',
  CARD: 'CARD',
  ENROLLMENT_OR_SIGNUP: 'ENROLLMENT_OR_SIGNUP',
  PROFILE: 'PROFILE',
  STATEMENT: 'STATEMENT',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  TRANSACTION: 'TRANSACTION',
  OTHER: 'OTHER',
} as const;

export interface CaseCreateRequest {
  /**
   * More detailed description of the Case
   * @minLength 1
   * @maxLength 3000
   * @pattern ^(?!\s*$)[\s\S]*$
   */
  description: string;
  /**
   * Subject of a Case
   * @minLength 1
   * @maxLength 50
   * @pattern ^(?!\s*$).+
   */
  subject: string;
  /** Case category */
  type: CaseCreateRequestType;
}

export interface CasesPaginationResponse {
  /** @minItems 0 */
  items: CasesDetails[];
  metadata: PaginationMetadata;
}

/**
 * Case category
 */
export type CasesDetailsType =
  (typeof CasesDetailsType)[keyof typeof CasesDetailsType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CasesDetailsType = {
  ACCOUNT: 'ACCOUNT',
  CARD: 'CARD',
  ENROLLMENT_OR_SIGNUP: 'ENROLLMENT_OR_SIGNUP',
  OTHER: 'OTHER',
  PROFILE: 'PROFILE',
  STATEMENT: 'STATEMENT',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  TRANSACTION: 'TRANSACTION',
} as const;

/**
 * Current status on case
 */
export type CasesDetailsStatus =
  (typeof CasesDetailsStatus)[keyof typeof CasesDetailsStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CasesDetailsStatus = {
  CLOSED: 'CLOSED',
  REOPEN: 'REOPEN',
  OPEN: 'OPEN',
} as const;

export interface ContactDetails {
  /** Agent identifier */
  agent: boolean;
  /** Contact name */
  name: string;
}

export interface CommentDetails {
  /**
   * Comment description or a copy of the main points of the comment.
   * @minLength 1
   * @maxLength 3000
   * @pattern ^(?!\s*$).+
   */
  comment: string;
  commentedBy: ContactDetails;
  /** Comment creation date */
  createdDate: string;
}

export interface CasesDetails {
  createdBy: ContactDetails;
  /** Date/Time the case was opened */
  createdDate: string;
  /** Case ID. A unique identifier for a case. */
  id: string;
  /** Current status on case */
  status: CasesDetailsStatus;
  /** Subject of a case */
  subject: string;
  /** Case category */
  type: CasesDetailsType;
  /** Date/Time the case was closed */
  updatedDate: string;
}

export interface PaginationMetadata {
  /** The number of items on a page */
  limit: number;
  /** The page number */
  page: number;
  /** Total number of items in all pages */
  totalItems: number;
}

export type MicrodepositVerificationResponseStatus =
  (typeof MicrodepositVerificationResponseStatus)[keyof typeof MicrodepositVerificationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MicrodepositVerificationResponseStatus = {
  VERIFIED: 'VERIFIED',
  FAILED: 'FAILED',
  FAILED_MAX_ATTEMPTS_EXCEEDED: 'FAILED_MAX_ATTEMPTS_EXCEEDED',
} as const;

/**
 * Microdeposit verification outcome
 */
export interface MicrodepositVerificationResponse {
  status: MicrodepositVerificationResponseStatus;
}

/**
 * Microdeposit amount verification
 */
export interface MicrodepositAmounts {
  /** @minItems 0 */
  amounts: number[];
}

export interface UpdateRecipientRequest {
  account?: RecipientAccount;
  partyDetails?: RecipientPartyDetails;
  status?: RecipientStatus;
}

export interface RecipientRequest {
  account?: RecipientAccount;
  /** Client identifier */
  clientId?: string;
  partyDetails?: RecipientPartyDetails;
  /** Related Party Identifier for Linked Accounts */
  partyId?: string;
  type?: RecipientType;
}

export interface Recipient {
  account?: RecipientAccount;
  /**
   * Account validation response
   * @minItems 1
   * @maxItems 10
   */
  accountValidationResponse?: AccountValidationResponse[];
  /** Client identifier */
  clientId?: string;
  /** The date and time the recipient was created */
  createdAt?: string;
  id: string;
  partyDetails: RecipientPartyDetails;
  /** Related Party Identifier for Linked Accounts */
  partyId?: string;
  status?: RecipientStatus;
  type?: RecipientType;
  /** The date and time the recipient was last updated */
  updatedAt?: string;
}

export type ListRecipientsResponseAllOf = {
  /**
   * Recipients available in current page
   * @minItems 0
   */
  recipients?: Recipient[];
};

export type ListRecipientsResponse = PageMetaData & ListRecipientsResponseAllOf;

export interface ProviderResponse {
  /** Microdeposit notification */
  mdNotification?: string;
  retryCount?: number;
}

export interface Details {
  /** Account number */
  accountNumber?: string;
  financialInstitutionId?: FinancialInstitutionId;
  /** Payment Check Contributing Status */
  paymentCheckContributingStatus?: string;
  providerResponse?: ProviderResponse;
}

export interface Responses {
  codes?: Codes;
  details?: Details;
  /** Name of the entity that provided the validation */
  provider?: string;
}

export interface AccountValidationResponse {
  /** Profile name to identify account validation configuration */
  profileName?: string;
  /** Unique identifier for a set of related requests */
  requestId?: string;
  /**
   * Account validation responses
   * @minItems 0
   */
  responses?: Responses[];
}

export interface ClearingSystemId {
  /** Routing number */
  id?: string;
  /** Routing code */
  idType?: string;
}

export interface FinancialInstitutionId {
  clearingSystemId?: ClearingSystemId;
}

export interface Result {
  /** Account validation response code */
  code?: number;
  /** Account validation response message, message is based on the code */
  message?: string;
}

export interface Codes {
  authentication?: Result;
  authenticationMicroDeposit?: Result;
  error?: Result;
  verification?: Result;
  verificationMicroDeposit?: Result;
}

/**
 */
export type RecipientStatus =
  (typeof RecipientStatus)[keyof typeof RecipientStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MICRODEPOSITS_INITIATED: 'MICRODEPOSITS_INITIATED',
  READY_FOR_VALIDATION: 'READY_FOR_VALIDATION',
  REJECTED: 'REJECTED',
} as const;

/**
 * Bank account details of the recipient.
 */
export interface RecipientAccount {
  countryCode: CountryCode;
  number: AccountNumber;
  /**
   * Routing information.
   * @minItems 1
   * @maxItems 3
   */
  routingInformation?: RoutingInformation[];
  type: AccountType;
}

/**
 * Type of routing code. Only USABA is supported in this version of Embedded Banking.
 */
export type RoutingCodeType =
  (typeof RoutingCodeType)[keyof typeof RoutingCodeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingCodeType = {
  USABA: 'USABA',
} as const;

/**
 * Type of transaction.
 */
export type RoutingInformationTransactionType =
  (typeof RoutingInformationTransactionType)[keyof typeof RoutingInformationTransactionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingInformationTransactionType = {
  ACH: 'ACH',
  RTP: 'RTP',
  WIRE: 'WIRE',
} as const;

/**
 * Routing number corresponding to the routing code type (currently only USABA compliant routing numbers are supported)
 * @pattern ^\d{9}$
 */
export type RoutingNumber = string;

export interface RoutingInformation {
  routingCodeType: RoutingCodeType;
  routingNumber: RoutingNumber;
  transactionType: RoutingInformationTransactionType;
}

/**
 * Type of bank account, either CHECKING or SAVINGS. Only required for ACH payments. Exclude field from payload completely if not needed.
 */
export type AccountType = (typeof AccountType)[keyof typeof AccountType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountType = {
  CHECKING: 'CHECKING',
  SAVINGS: 'SAVINGS',
} as const;

/**
 * Payment Routing Number or Demand Deposit Account number.
 * @pattern ^\d{1,35}$
 */
export type AccountNumber = string;

/**
 * Type of contact information being provided
 */
export type RecipientContactContactType =
  (typeof RecipientContactContactType)[keyof typeof RecipientContactContactType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientContactContactType = {
  EMAIL: 'EMAIL',
  WEBSITE: 'WEBSITE',
  PHONE: 'PHONE',
} as const;

export interface RecipientContact {
  /**
   * Type of contact information being provided
   */
  contactType: RecipientContactContactType;
  /**
   * E.164 format compatible telephone country code
Mandatory for contactType PHONE

   * @pattern ^\+[1-9]\d{0,2}$
   */
  countryCode?: string;
  /**
   * Contact information corresponding to contactType: 
PHONE - E.164-compliant telephone number (excluding country code).
EMAIL - Email address (addr-spec in Section 3.4 of RFC 5322).
WEBSITE - URL starting with http:// or https://.

   * @minLength 1
   * @maxLength 2048
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  value: string;
}

/**
 */
export type PartyType = (typeof PartyType)[keyof typeof PartyType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyType = {
  INDIVIDUAL: 'INDIVIDUAL',
  ORGANIZATION: 'ORGANIZATION',
} as const;

/**
 * Two letter country code based on ISO 3166 standard (currently only US is supported)
 */
export type CountryCode = (typeof CountryCode)[keyof typeof CountryCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CountryCode = {
  US: 'US',
} as const;

/**
 * Address details for the recipient. Mandatory for payments using the RTP payment type.
 */
export interface RecipientAddress {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   */
  city: string;
  countryCode: CountryCode;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 30
   */
  state?: string;
}

export interface RecipientPartyDetails {
  address?: RecipientAddress;
  /**
   * Recipient company name. Mandatory for recipient type ORGANIZATION.

   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  businessName?: string;
  /**
   * Contact details for the recipient.
   * @minItems 0
   */
  contacts?: RecipientContact[];
  /**
   * Recipient's first name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  firstName?: string;
  /**
   * Recipient's last name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  lastName?: string;
  type: PartyType;
}

/**
 */
export type RecipientType = (typeof RecipientType)[keyof typeof RecipientType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientType = {
  RECIPIENT: 'RECIPIENT',
  LINKED_ACCOUNT: 'LINKED_ACCOUNT',
  SETTLEMENT_ACCOUNT: 'SETTLEMENT_ACCOUNT',
} as const;

export type CardLimitChangeRequestMaxDailySpend = {
  /** Whether this limit is active/inactive */
  active?: boolean;
  /**
   * The maximum amount that can be spent in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  value?: number;
};

export type CardLimitChangeRequestMaxDailyCashWithdrawal = {
  /** Whether this limit is active/inactive */
  active?: boolean;
  /**
   * The maximum amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  value?: number;
};

/**
 * An object to request a change in card limit(s).
 */
export interface CardLimitChangeRequest {
  maxDailyCashWithdrawal?: CardLimitChangeRequestMaxDailyCashWithdrawal;
  maxDailySpend?: CardLimitChangeRequestMaxDailySpend;
}

/**
 * An object to request a card pin number be changed.
 */
export interface CardPinChangeRequest {
  /** 4 digit ATM pin to be used for associated card. */
  pin?: string;
}

/**
 * Reason for replacing card.
 */
export type CardReplaceRequestReason =
  (typeof CardReplaceRequestReason)[keyof typeof CardReplaceRequestReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardReplaceRequestReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DAMAGED: 'DAMAGED',
  OTHER: 'OTHER',
} as const;

/**
 * An object to request a card be replaced.
 */
export interface CardReplaceRequest {
  /** Reason for replacing card. */
  reason?: CardReplaceRequestReason;
}

/**
 * Reason for cancelling card.
 */
export type CardCancelRequestReason =
  (typeof CardCancelRequestReason)[keyof typeof CardCancelRequestReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardCancelRequestReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  OTHER: 'OTHER',
} as const;

/**
 * An object to request a card be cancelled.
 */
export interface CardCancelRequest {
  /** Reason for cancelling card. */
  reason?: CardCancelRequestReason;
}

export interface ApiErrorV2 {
  /**
   * Provides additional context and detail on the validation errors
   * @minItems 0
   * @maxItems 100
   */
  context?: ApiErrorReasonV2[];
  /** HTTP status code */
  httpStatus: number;
  /** Client provided request identifier */
  requestId?: string;
  /** Short humanly-readable title of the error */
  title: string;
  /** Internal assigned traced identifier */
  traceId?: string;
}

/**
 * An object with response corresponding to the status of the card.
 */
export interface CardUpdateResponse {
  /** New Card Identifier to Update */
  id?: string;
  /** Message for operation status. */
  message?: string;
}

/**
 * New status of the card after request. Can be locked/unlocked/replaced/cancelled status.
Optional field. Only use if you want to update the status of the card.

 */
export type CardUpdateRequestStatus =
  (typeof CardUpdateRequestStatus)[keyof typeof CardUpdateRequestStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestStatus = {
  LOCKED: 'LOCKED',
  UNLOCKED: 'UNLOCKED',
  REPLACED: 'REPLACED',
  CANCELLED: 'CANCELLED',
} as const;

/**
 * Reason for replacing card. Only required if status is set to REPLACED.

 */
export type CardUpdateRequestReplacementReason =
  (typeof CardUpdateRequestReplacementReason)[keyof typeof CardUpdateRequestReplacementReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestReplacementReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DAMAGED: 'DAMAGED',
  DEFECTIVE: 'DEFECTIVE',
} as const;

/**
 * Reason for cancelling card. Only required if status is set to CANCELLED.

 */
export type CardUpdateRequestCancellingReason =
  (typeof CardUpdateRequestCancellingReason)[keyof typeof CardUpdateRequestCancellingReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestCancellingReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DEACTIVE: 'DEACTIVE',
} as const;

/**
 * An Object containing Card Update Request

 */
export interface CardUpdateRequest {
  /** Reason for cancelling card. Only required if status is set to CANCELLED.
   */
  cancellingReason?: CardUpdateRequestCancellingReason;
  /** Clears daily cashwithdrawal limits on this card. Set value to TRUE to remove any daily cashwithdrawal limits. If set to TRUE, any maxCashWithdrawalLimit limit is ignored. You can still apply daily spend limits even when clearCashWithdrawalLimit is set to TRUE.
   */
  clearCashWithdrawalLimit?: boolean;
  /** Clears spending limits on this card. Set value to TRUE to remove any daily spending limits. If set to TRUE, any maxSpendLimit limit is ignored. You can still apply daily cash withdrawal limits  even when clearSpendLimit is set to TRUE.
   */
  clearSpendLimit?: boolean;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxSpendLimit?: number;
  /** 4 digit ATM pin to be used for associated card.
Optional field. Only include if setting a new PIN.
 */
  pin?: string;
  /** Reason for replacing card. Only required if status is set to REPLACED.
   */
  replacementReason?: CardUpdateRequestReplacementReason;
  /** New status of the card after request. Can be locked/unlocked/replaced/cancelled status.
Optional field. Only use if you want to update the status of the card.
 */
  status?: CardUpdateRequestStatus;
}

/**
 * An Object with Card Detail Response for specific Card Id

 */
export interface CardDetailResponse {
  /** Account Identifier/ Payment Routing Number
   */
  accountId: string;
  /** Web link to the Card Holder Profile
   */
  link: string;
}

/**
 * An Object containing Create Debit Card Response

 */
export interface CreateDebitCardResponse {
  /** Account Identifier/ Payment Routing Number
   */
  accountId?: string;
  /** Card Identifier
   */
  id?: string;
  /** Link to the Customer Profile
   */
  link?: string;
  /** Customer Card Information Message
   */
  message?: string;
}

/**
 * An Object containing Create Debit Card Request

 */
export interface CreateDebitCardRequest {
  /** Account Identifier/ Payment Routing Number
   */
  accountId: string;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxSpendLimit?: number;
  /**
   * Party Id of the Card Holder

   */
  relatedPartyId: string;
}

export interface CardDetailsErrorResponse {
  /** Freeform explanatory text for the error.
   */
  errorDescription: string;
  /** A code defined by the service for the external partner that includes a more specific information of what caused the error.
   */
  externalErrorCode?: string;
  /** A code defined by the API provider that describes the specific error for a given API. This code provides more fine grained information than the httpStatusCode. As an example if an API provides an httpStatusCode of 400 they may also include the serviceErrorCode that includes more specific information of what caused a 400 response. (i.e. INVALID_EMAIL, INVALID_PHONE_NUMBER, etc)
   */
  serviceErrorCode?: string;
}

/**
 * The current status of the card.
 */
export type DebitCardStatus =
  (typeof DebitCardStatus)[keyof typeof DebitCardStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DebitCardStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPEND: 'SUSPEND',
  DAMAGED: 'DAMAGED',
  DEACTIVE: 'DEACTIVE',
  DEFECTIVE: 'DEFECTIVE',
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  UNDELIVER: 'UNDELIVER',
  IRREGACT: 'IRREGACT',
  OTHER: 'OTHER',
} as const;

export interface DebitCard {
  /** Account identifier or payment routing number. */
  accountId: string;
  /** Card expiration date. */
  expirationDate: string;
  /** First name of the client. */
  firstName: string;
  /** Unique identifier for the card. */
  id: string;
  /** Last Four digits of the card number. */
  last4: string;
  /** Last name of the client. */
  lastName: string;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  maxSpendLimit?: number;
  /** Middle name of the client. */
  middleName: string;
  /** The current status of the card. */
  status: DebitCardStatus;
}

export interface DebitCardsResponse {
  /**
   * List of debit cards for a specific client
   * @minItems 0
   */
  items: DebitCard[];
  metadata: PageMetaData;
}

/**
 * Supported document types.
 */
export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentType = {
  IRS_DOCUMENT_TIN: 'IRS_DOCUMENT_TIN',
  ARTICLES_OF_INCORPORATION: 'ARTICLES_OF_INCORPORATION',
  MOA: 'MOA',
  MAA: 'MAA',
  CONSTITUTIONAL_DOCUMENT: 'CONSTITUTIONAL_DOCUMENT',
  TRUST_DEED: 'TRUST_DEED',
  PARTNERSHIP_AGREEMENT: 'PARTNERSHIP_AGREEMENT',
  LLC_AGREEMENT: 'LLC_AGREEMENT',
  OPERATING_AGREEMENT: 'OPERATING_AGREEMENT',
  OFFERING_MEMO: 'OFFERING_MEMO',
  BANKING_LICENSE: 'BANKING_LICENSE',
  BUSINESS_LICENSE: 'BUSINESS_LICENSE',
  BUSINESS_REGISTRATION_CERT: 'BUSINESS_REGISTRATION_CERT',
  OTHER_GOV_REGISTRATION_DOCS: 'OTHER_GOV_REGISTRATION_DOCS',
  SEC_FILINGS_10K: 'SEC_FILINGS_10K',
  PASSPORT: 'PASSPORT',
  SSN_CARD: 'SSN_CARD',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE',
  GOV_ISSUED_ID_CARD: 'GOV_ISSUED_ID_CARD',
  TERMS_CONDITION: 'TERMS_CONDITION',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
} as const;

/**
 * - Additional information about the document in a key-value pair array.
- The processing domain should only support the specific keys for thier relevant workflows.
- The productType and documentType combination will determine the 
  list of allowed meta-data keys and the format of their values.
    - For productype = EB and documentType = ( PASSPORT | SSN_CARD | DRIVERS_LICENSE | GOV_ISSUED_ID_CARD ),

      Mandatory meta-data key list = ["partyId"] and allowed meta-data value format = ["uuid"].

      Example - {"key": "partyId", "value": "73bd1c1d-6635-43ff-a8e5-b252926bdd9e"} .

 */
export interface DocumentMetadata {
  /** Key value can be PARTY_ID or COUNTRY_CODE */
  key: DocumentMetadataKey;
  /**
   * value can be UUID which represents a partyId or a ISO two characters country code e.g. US
   * @minLength 1
   * @maxLength 50
   */
  value: string;
}

export interface DocumentDetails {
  documentType?: DocumentType;
  /** The unique id generated by the system for the uploaded document,  which can be used for future retrieval.
   */
  id?: string;
  /**
   * @minItems 0
   * @maxItems 2
   */
  metadata?: DocumentMetadata[];
  productType?: ProductType;
}

export interface DocumentUploadData {
  documentType: DocumentType;
  /**
   * @minItems 0
   * @maxItems 2
   */
  metadata?: DocumentMetadata[];
  productType: ProductType;
}

export interface DocumentsDetails {
  documentType?: string;
  id?: string;
  /**
   * @minItems 0
   * @maxItems 100
   */
  metadata?: DocumentMetadata[];
  productTypes?: ProductTypesArray;
}

/**
 * @minItems 0
 */
export type DocumentsDetailsArray = DocumentsDetails[];

/**
 * Key value can be PARTY_ID or COUNTRY_CODE
 */
export type DocumentMetadataKey =
  (typeof DocumentMetadataKey)[keyof typeof DocumentMetadataKey];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentMetadataKey = {
  PARTY_ID: 'PARTY_ID',
  COUNTRY_CODE: 'COUNTRY_CODE',
} as const;

/**
 * Product type identifies which domain the document is being uploaded to.
 */
export type ProductType = (typeof ProductType)[keyof typeof ProductType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductType = {
  EB: 'EB',
  EP: 'EP',
} as const;

/**
 * @minItems 0
 * @maxItems 100
 */
export type ProductTypesArray = ProductType[];

export type RoleResponse = BaseRole & {
  /** @minItems 0 */
  resourceTypes?: string[];
};

export interface ListRoleResponse {
  /**
   * @minItems 0
   * @maxItems 5
   */
  items?: RoleResponse[];
  metadata?: PageMetaData;
}

export type UserApiAction = (typeof UserApiAction)[keyof typeof UserApiAction];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserApiAction = {
  ADD: 'ADD',
  REMOVE: 'REMOVE',
} as const;

export interface RoleRequest {
  action?: UserApiAction;
  /**
   * Defines the role type i.e DEBIT_CARD_HOLDER, AUTH_USER
   * @pattern ^[a-zA-Z_]+$
   */
  id: string;
  /**
   * The ID corresponding to the resource.
   * @pattern ^.*$
   */
  resourceId?: string;
  /**
   * Defines the actual resource for a debit card holder, the resource would be the DEBIT_CARD_NO.
   * @pattern ^.*$
   */
  resourceType?: string;
}

export type UpdateUserRequest = BaseUser & {
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: RoleRequest[];
};

export type CreateUserRequest = BaseUser & {
  /**
   * The client ID of the user.
   * @pattern ^\d{10}$
   */
  clientId?: string;
  /** The client party id to link the user to. This is applicable when the party already exists for a C2.
   */
  relatedPartyId?: string;
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: RoleRequest[];
};

export interface UserApiErrorReason {
  /**
   * Part of the request which is responsible for the reason
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  field?: string;
  /**
   * Message describing the reason. This message can typically be displayed to your platform's users, except in cases specified otherwise
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  message: string;
  /**
   * Readable reason returned to indicate a reason behind the error occurred
   * @minLength 1
   * @maxLength 256
   * @pattern ^[A-Z0-9_]+$
   */
  reason: string;
  /**
   * Rejected value from the request which is responsible for the reason
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  rejectedValue?: string;
}

export interface UserApiError {
  /**
   * Readable code returned to indicate an error occurred
   * @minLength 1
   * @maxLength 99
   * @pattern ^[A-Z0-9_]+$
   */
  error: string;
  /**
   * Message describing the error. This message can typically be displayed to your platform's users, except in cases specified otherwise
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  message: string;
  /** @minItems 0 */
  reasons?: UserApiErrorReason[];
  /**
   * Trace Id
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  traceId?: string;
}

export interface ListUserResponse {
  /**
   * @minItems 0
   * @maxItems 25
   */
  items?: UserResponse[];
  metadata?: PageMetaData;
}

export interface BaseRole {
  /**
   * A brief description for the role.
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  description?: string;
  /** @pattern ^[a-zA-Z_]+$ */
  id: string;
  /**
   * A friendly name for the role.
   * @minLength 1
   * @maxLength 32
   * @pattern ^.*$
   */
  label?: string;
}

export type UserRoleResponse = BaseRole & {
  description?: string;
  id?: string;
  label?: string;
  /**
   * The ID of the resource
   * @pattern ^.*$
   */
  resourceId?: string;
  /**
   * The type of resource on which the entitlement should be associated
   * @pattern ^.*$
   */
  resourceType?: string;
};

/**
 * Processing status during user/resource creation/update.
 */
export type ProcessingStatus =
  (typeof ProcessingStatus)[keyof typeof ProcessingStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProcessingStatus = {
  Setup_In_Progress: 'Setup In Progress',
  Setup_Complete: 'Setup Complete',
  Setup_Failed: 'Setup Failed',
  Update_In_Progress: 'Update In Progress',
  Update_Complete: 'Update Complete',
  Update_Failed: 'Update Failed',
} as const;

/**
 * Status of the user derived from the identity provider.
 */
export type Status = (typeof Status)[keyof typeof Status];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  INVITED: 'INVITED',
  ACTIVE: 'ACTIVE',
  LOCKED: 'LOCKED',
  NOT_AVAILABLE: 'NOT_AVAILABLE',
  REMOVED: 'REMOVED',
} as const;

/**
 * Type of address e.g. 'Primary Residence' | 'Principal place of business'.
 */
export type AddressType = (typeof AddressType)[keyof typeof AddressType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddressType = {
  Principal_place_of_business: 'Principal place of business',
  Local_office: 'Local office',
  Primary_Residence: 'Primary Residence',
  Business_street_address: 'Business street address',
} as const;

export interface Address {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  addressType?: AddressType;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format.
   * @maxLength 30
   * @pattern ^[a-z-A-Z ]+$
   */
  state: string;
}

/**
 * Phone Number Information of the user

 */
export interface SchemasPhone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^((\+\d{1,3})|(\d{1,4}))$
   */
  countryCode: string;
  /**
   * @minLength 4
   * @maxLength 15
   * @pattern ^\d{1,15}$
   */
  phoneNumber: string;
}

export interface BaseUser {
  address?: Address;
  /**
   * Email of the user
   * @minLength 7
   * @maxLength 50
   */
  emailAddress?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  firstName?: string;
  /**
   * Last name of the individual in case of party type being an  individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.

   * @minLength 1
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  middleName?: string;
  phone?: SchemasPhone;
  /**
   * Username of the user. If not provided during user creation, system will use emailAddress as username. If provided, then it
 - Can be 5 to 30 characters long.
 - Can allow special characters underscore or dot or @
 - Can neither start nor end with any special characters
 - Cannot contain consecutive special characters

   * @minLength 5
   * @maxLength 30
   * @pattern ^(?=.{6,30}$)(?![_.@])(?!.*[_.@]{2})[a-zA-Z0-9._@]+(?<![_.@])$
   */
  username?: string;
}

export type UserResponse = BaseUser & {
  /** @pattern ^\d{10}$ */
  clientId?: string;
  /**
   * @minLength 1
   * @maxLength 36
   * @pattern ^[a-zA-Z0-9-]+$
   */
  id?: string;
  processingStatus?: ProcessingStatus;
  /** The client party id to link the user to. This is applicable when the party already exists for a C2.
   */
  relatedPartyId?: string;
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: UserRoleResponse[];
  status?: Status;
};

export type FetchLevel = (typeof FetchLevel)[keyof typeof FetchLevel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FetchLevel = {
  USER_STATUS: 'USER_STATUS',
  PARTY: 'PARTY',
  ROLES: 'ROLES',
} as const;

export interface AttestationRequest {
  /** Unique identifier of the legal document that must be attested by the user. For example, terms & conditions or disclosure & consent documents. */
  documentId: string;
  /**  First and last name of the attester. */
  fullName: string;
  /**  Attested IP address */
  ipAddress: string;
}

export type AttestationsRequest = AttestationRequest;

export type VerificationsRequest = VerificationRequest;

export interface ClientVerificationsInformationRequest {
  /** @minItems 0 */
  attestations?: AttestationsRequest[];
  /** @minItems 0 */
  verifications?: VerificationsRequest[];
}

export interface AnswerRequest {
  /**
   * The answer/s of a question. Can contain one or more elements. In case where response options are provided, it has to be the id/s depending on single or list format. In case of other formats e.g. freeText, there can be only one element.

   * @minItems 0
   * @maxItems 100
   */
  values: string[];
}

export interface VerificationIdRequest {
  /** The unique identifier for a personal identification verification. */
  id: string;
}

export interface VerificationRequest {
  response: AnswerRequest;
  verification: VerificationIdRequest;
}

export interface AdditionalDocument {
  /** Unique identifier of the document which user uploaded */
  documentId?: string;
  /** Identity documents level - The category of document which is predefined. Primary is one of the categories and has some limited set of applicable documents. */
  documentLevel?: string;
  /** Specifies type of the document uploaded */
  documentType?: string;
  /** Specifies number of days remaining to upload documents  */
  numberOfDaysRemainingToUpload?: string;
  /** Related Party id */
  partyId?: string;
  /** Specifies the party type, for Legal Entity it is Organization and for Related party e.g. Owner/Controller etc. it is Individual */
  partyType?: string;
  /** Status of the document. REQUESTED means the document needs to be provided */
  status?: string;
  /**
   * @minItems 0
   * @maxItems 100
   */
  supportedDocuments?: string[];
}

export type AdditionalDocuments = AdditionalDocument;

export interface ClientVerificationsInformationResponse {
  /** @minItems 0 */
  additionalDocuments?: AdditionalDocuments[];
  /** @minItems 0 */
  attestations?: AttestationsResponse[];
  /** If the status is present in the response, verifications are submitted for the client */
  status?: string;
  /** @minItems 0 */
  verifications?: VerificationsResponse[];
}

export interface AttestationResponse {
  /** date time of submission in ISO format yyyy-MM-ddTHH:mm:ss */
  attestationDateTime?: string;
  /** Unique identifier of the legal document that must be attested by the user. For example, terms & conditions or disclosure & consent documents. */
  documentId?: string;
  /** Name of the document */
  documentName?: string;
  /** The type of document. Can be terms and conditions or disclosure and consent documents. */
  documentType?: string;
  /** Document version */
  documentVersion?: string;
  /**  First and last name of the attester. */
  fullName?: string;
  /**  Attested IP address */
  ipAddress?: string;
}

export type AttestationsResponse = AttestationResponse;

export interface AnswerOption {
  /** Internal id value, not to be shared with user */
  id?: string;
  /** External readable value to be presented to the user. */
  label?: string;
}

export interface AnswerResponse {
  /** @minItems 0 */
  answerOptions?: AnswerOption[];
  /** Can be single for one item in the values or list in case of more than one values. The other options are word, freeText, alphaNumeric and there will be only one element allowed */
  format?: string;
  /** max length allowed in values field. In case of freeText, the maximum length is 2000 */
  maxLength?: number;
  /** Id of parent Question */
  parentId?: string;
  /** date time of submission in ISO format yyyy-MM-ddTHH:mm:ss */
  updatedDateTime?: string;
  /**
   * The answer/s of a question. Can contain one or more elements.

   * @minItems 0
   */
  values?: string[];
}

export interface VerificationIdResponse {
  /** The unique identifier for a personal identification verification. */
  id?: string;
  /** verification question. */
  label?: string;
}

export interface VerificationResponse {
  response?: AnswerResponse;
  verification?: VerificationIdResponse;
}

export type VerificationsResponse = VerificationResponse;

export type UpdateClientResponseAllOf = {
  /**
   * The products available for clients.

   * @minItems 0
   */
  products?: string[];
  /** @minItems 0 */
  relatedParties?: UpdateRelatedPartiesResponse[];
};

export type UpdateClientResponse = UpdateEntityDetailBusinessRequest &
  UpdateClientResponseAllOf;

export type UpdateRelatedPartiesResponseAllOf = {
  /** Client id, that uniquely identifies the client.
   */
  id: string;
};

export type UpdateRelatedPartiesResponse = UpdateRelatedPartyRequest &
  UpdateRelatedPartiesResponseAllOf;

export type UpdateRelatedPartiesRequestAllOf = {
  /** The action like ADD, UPDATE, REMOVE
   */
  action: string;
};

export type UpdateRelatedPartiesRequest = UpdateRelatedPartyRequest &
  UpdateRelatedPartiesRequestAllOf;

export type UpdateClientRequestAllOf = {
  /** @minItems 0 */
  relatedParties?: UpdateRelatedPartiesRequest[];
};

export type UpdateClientRequest = UpdateEntityDetailBusinessRequest &
  UpdateClientRequestAllOf;

export type UpdateRelatedPartyRequestAllOf = {
  /** The date of birth (yyyy-MM-dd) of the individual in case of party type being an individual. This field is not required for the party type Organization.
   */
  birthDate?: string;
  /** The business?s legal name. It is the official name of the person or entity that owns a company. And, it?s the name used on your government forms and business paperwork. This field is only required when party type is NON-IND
   */
  businessName?: string;
  /** Email of the individual.
   */
  email?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   */
  firstName?: string;
  /** Unique identifier for this party. It is only required for UPDATE and REMOVE actions
   */
  id?: string;
  /** Job title in case of party type being an individual. JobTitle is required field for Controllers. Also, If Privately Owned Business is selected as the business type, Job Title should be a required field for Decision Makers. e.g. CEO|CFO|COO|President|Chairman|Senior Branch Manager|Other
   */
  jobTitle?: string;
  /**
   * In case on jobTitle is Other then Job title description is required.This field can be set to empty by passing field value as ("") in request.

   * @maxLength 50
   */
  jobTitleDescription?: string;
  /**
   * Last name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.This field can be set to empty by passing field value as ("") in request.

   * @maxLength 30
   */
  middleName?: string;
  /** Nature of ownership e.g. Direct|Indirect.This field can be set to empty by passing field value as ("") in request.
   */
  natureOfOwnership?: string;
  /**
   * A Party role which could have one or more of the following values: CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, PAYEE, DECISION_MAKER
If a SMB controller and owner is the same person - you have to send two parties with the distinct partyRoles e.g. [ CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, DECISION_MAKER ]

   * @minItems 0
   * @maxItems 100
   */
  partyRole?: string[];
  /** A Party type which could have one of the following distinct values: Organization, Individual, NonIndividual
   */
  partyType?: string;
  soleOwner?: boolean;
};

export type UpdateEntityDetailBusinessRequestAllOf = {
  /** Client id, that uniquely identifies the client.
   */
  id?: string;
};

export type UpdatePartyDetailBusinessAllOf = {
  /** The business?s alias name. It is the other alias name of the  entity that owns a company.This field can be set to empty by passing field value as ("") in request.
   */
  businessAliasName?: string;
  /** The business?s description.
   */
  businessDescription?: string;
  /** The business?s legal name. It is the official name of the person or entity that owns a company.
And, it?s the name used on your government forms and business paperwork
 */
  businessName?: string;
  /** The different business entity types that can be selected e.g. Privately Owned Business | Sole Proprietorship
   */
  businessType?: string;
  /** Country code in alpha-2 format */
  countryOfFormation?: string;
  /**
   * Email of the client.

   * @maxLength 50
   */
  email?: string;
  /** If entitiesInOwnership is true, are there any businesses included in your ownership hierarchy? e.g. true|false. entitiesInOwnership is required for Privately Owned Business.
   */
  entitiesInOwnership?: boolean;
  /** Distinct industry category. e.g. - Accommodation and Food Services - Administrative and Support and Waste Management and Remediation Services - Agriculture, Forestry, Fishing and Hunting (not covered in economic census) - Arts, Entertainment, and Recreation - Construction - Educational Services - Finance and Insurance - Health Care and Social Assistance - Individuals - Information - Management of Companies and Enterprises - Manufacturing - Mining, Quarrying, and Oil and Gas Extraction - Other Services (except Public Administration) - Professional, Scientific, and Technical Services - Public Administration (not covered in economic census) - Real Estate and Rental and Leasing - Retail Trade - Transportation and Warehousing - Utilities - Wholesale Trade
   */
  industryCategory?: string;
  /** Industry type.
   */
  industryType?: string;
  /** Legal Structure of the business entity. Legal structure is required for Privately Owned Business and Sole Proprietorship.
   */
  legalStructure?: string;
  /** Are there any individuals who own 25% or more of your business? e.g. true|false. significantOwnership is required for Privately Owned Business. If Significant Ownership is selected as True, At least one related party should have a role of owner.
   */
  significantOwnership?: boolean;
  /** Website of the client. website is required if websiteAvailable is true.This field can be set to empty by passing field value as ("") in request.
   */
  website?: string;
  /** Does your business have a website? e.g. true|false
   */
  websiteAvailable?: boolean;
  /** Year of formation. Max and Min length is 4.
   */
  yearOfFormation?: string;
};

export type UpdatePartyDetailBusiness = UpdatePartyDetailCommon &
  UpdatePartyDetailBusinessAllOf;

export type UpdateEntityDetailBusinessRequest = UpdatePartyDetailBusiness &
  UpdateEntityDetailBusinessRequestAllOf;

export interface UpdateIdentityDTO {
  /** The action like ADD, UPDATE, REMOVE
   */
  action: string;
  /** Description of identification type e.g. Social Security Number */
  idDescription?: string;
  /** Identification issuer country name e.g. US */
  idIssuer: string;
  /** IdType denotes the type of taxpayer identification numbers e.g. SSN/EIN. EIN is acceptable idType for Privately Owned Business. Sole Proprietorship can have EIN/SSN as idType. For individuals like Owners and Controllers SSN is accepted as idType.
   */
  idType: string;
  /** Value of the identification type. EIN/SSN must be of 9 digits. */
  idValue: string;
}

/**
 * Phone Number Information of the account

 */
export interface UpdatePhone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^((\+\d{1,3})|(\d{1,4}))$
   */
  countryCode?: string;
  /**
   * @minLength 7
   * @maxLength 14
   * @pattern ^\d{7,14}$
   */
  phoneNumber?: string;
}

export interface UpdateAddressDto {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.This field can be set to empty by passing field value as ("") in request.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.This field can be set to empty by passing field value as ("") in request.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principle Place Of Business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 2
   * @pattern ^[a-z-A-Z ]+$
   */
  state?: string;
}

export interface UpdatePartyDetailCommon {
  address?: UpdateAddressDto;
  /** @minItems 0 */
  identities?: UpdateIdentityDTO[];
  phone?: UpdatePhone;
}

export type UpdateRelatedPartyRequest = UpdatePartyDetailCommon &
  UpdateRelatedPartyRequestAllOf;

export type RelatedPartyRequestAllOf = { [key: string]: unknown };

export type RelatedPartyRequest = RelatedParty & RelatedPartyRequestAllOf;

export type RelatedPartiesRequest = RelatedPartyRequest;

export type CreateClientRequestAllOf = {
  /** The jurisdiction where the client would be onboarding.
   */
  jurisdiction?: string;
  /**
   * The products available for clients in a jurisdiction.

   * @minItems 0
   * @maxItems 100
   */
  products: string[];
  /** @minItems 0 */
  relatedParties: RelatedPartiesRequest[];
};

export type PartyDetailBusinessRequestAllOf = { [key: string]: unknown };

export type PartyDetailBusinessRequest = PartyDetailBusiness &
  PartyDetailBusinessRequestAllOf;

export type EntityDetailBusinessRequest = PartyDetailBusinessRequest;

export type CreateClientRequest = EntityDetailBusinessRequest &
  CreateClientRequestAllOf;

/**
 * Part of the request which is responsible for the reason
 */
export type ApiErrorReasonV2Location =
  (typeof ApiErrorReasonV2Location)[keyof typeof ApiErrorReasonV2Location];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiErrorReasonV2Location = {
  BODY: 'BODY',
  QUERY: 'QUERY',
  PATH: 'PATH',
  HEADER: 'HEADER',
} as const;

export interface ApiErrorReasonV2 {
  /** Short code that identifies the error - publicly cataloged and documented */
  code?: string;
  /** The location of the property or parameter in error */
  field?: string;
  /** Part of the request which is responsible for the reason */
  location?: ApiErrorReasonV2Location;
  /** Message describing the reason. This message can typically be displayed to your platform's users, except in cases specified otherwise */
  message: string;
}

export interface ApiError {
  /**
   * Provides additional context and detail on the validation errors
   * @minItems 0
   * @maxItems 100
   */
  context?: ApiErrorReasonV2[];
  /** HTTP status code */
  httpStatus: number;
  /** Client provided request identifier */
  requestId?: string;
  /** Short humanly-readable title of the error */
  title: string;
  /** Internal assigned traced identifier */
  traceId?: string;
}

export interface ListClientInformationResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  items?: ClientInformationResponse[];
  metadata?: PageMetaData;
}

export type ClientInformationResponseAllOf = {
  /** Date the profile was created.
   */
  createdAt?: string;
  /** Once KYC has completed and approved, clients will be able to make payments out of their Embedded Bank Account.
This flag will be set to FALSE until this process completes. Only present for clients.
 */
  enablePayouts?: boolean;
  /** Client ID. The unique identifier for a client.
   */
  id: string;
  /** The jurisdiction where the client would be onboarding.
   */
  jurisdiction?: string;
  /** The client onboarding status */
  onboardingStatus?: string;
  /** Client ID of the platform entity the client is onboarded to.
   */
  parentClientId?: string;
  /**
   * The products available for clients in a jurisdiction.

   * @minItems 0
   * @maxItems 100
   */
  products?: string[];
  /**
   * @minItems 0
   * @maxItems 100
   */
  relatedParties?: RelatedPartyResponse[];
  /** active | deleted */
  status?: string;
};

export type RelatedPartyResponseAllOf = {
  /** Individual/NonIndividual client id, as UUID, that uniquely identifies the resource.
   */
  id: string;
  /** Status of the request. Can be active or deleted. */
  status?: string;
};

export type RelatedPartyAllOf = {
  /**
   * The date of birth (yyyy-MM-dd) of the individual in case of party type being an individual. This field is not required for the party type Organization.

   * @pattern ([0-9]{4})-(?:[0-9]{2})-([0-9]{2})
   */
  birthDate?: string;
  /**
   * The business?s legal name. It is the official name of the person or entity that owns a company. And, it?s the name used on your government forms and business paperwork. This field is only required when party type is NonIndividual

   * @pattern ^(?![-.%/+&@,';:#()_])(?!.*[-.%/+&@,';:#()_]{2})(?!.*[-.%/+&@,';:#()_]$).*$
   */
  businessName?: string;
  /**
   * Email of the individual.

   * @maxLength 50
   * @pattern (^$)|(^([^,:;=@"'\s()\[\]]+)+@([a-zA-Z-0-9-]+\.)+[a-zA-Z]{2,}$)
   */
  email?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  firstName?: string;
  /** Job title in case of party type being an individual. JobTitle is required field for Controllers. Also, If Privately Owned Business is selected as the business type, Job Title should be a required field for Decision Makers. e.g. CEO|CFO|COO|President|Chairman|Senior Branch Manager|Other
   */
  jobTitle?: string;
  /**
   * In case on jobTitle is Other then Job title description is required.

   * @maxLength 50
   */
  jobTitleDescription?: string;
  /**
   * Last name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.

   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  middleName?: string;
  /** Nature of ownership e.g. Direct|Indirect
   */
  natureOfOwnership?: string;
  /**
   * A Party role which could have one or more of the following values: CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, PAYEE, DECISION_MAKER
If a SMB controller and owner is the same person - you have to send two parties with the distinct partyRoles e.g. [ CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, DECISION_MAKER ]

   * @minItems 0
   * @maxItems 100
   */
  partyRole?: string[];
  /** A Party type which could have one of the following distinct values: Organization, Individual, NonIndividual
   */
  partyType?: string;
  soleOwner?: boolean;
};

export type RelatedParty = PartyDetailCommon & RelatedPartyAllOf;

export type RelatedPartyResponse = RelatedParty & RelatedPartyResponseAllOf;

export type PartyDetailBusinessAllOf = {
  /** Any alias names for the business connected to the client.
   */
  businessAliasName?: string;
  /** The business?s description.
   */
  businessDescription?: string;
  /**
   * The business?s legal name. It is the official name of the person or entity that owns a company. Must be the name used on the client's government forms and business paperwork

   * @pattern ^(?![-.%/+&@,';:#()_])(?!.*[-.%/+&@,';:#()_]{2})(?!.*[-.%/+&@,';:#()_]$).*$
   */
  businessName?: string;
  /** The type of business connected to the client. You can use the Reference Data resource to get a list of acceptable values. Examples include: Privately Owned Business. Sole Proprietorship.
   */
  businessType?: string;
  /** Country code in alpha-2 format */
  countryOfFormation?: string;
  /**
   * Email of the client.

   * @maxLength 50
   * @pattern (^$)|(^([^,:;=@"\\\s()\[\]]+)+@([a-zA-Z-0-9-]+\.)+[a-zA-Z]{2,}$)
   */
  email?: string;
  /** Entities in ownership means that one or more businesses own part of the business conected to the client. Always required for a Privately Owned Business.
   */
  entitiesInOwnership?: boolean;
  /** The industry category of the business connected to the client. For example, Accommodation and Food Services. You can use the Reference Data resource to get a list of acceptable values.
   */
  industryCategory?: string;
  /** The industry type of the business connected to the client. You can use the Reference Data resource to get a list of acceptable values.
   */
  industryType?: string;
  /** Legal Structure of the business entity. Legal structure is required for Privately Owned Business and Sole Proprietorship. Distinct legal structure. e.g. - Limited Liability Company - Corporation - Limited Partnership - Sole Proprietorship
   */
  legalStructure?: string;
  /** The parent (platform) relationship owner's ID. */
  parentClientId?: string;
  /** Significant ownership means there individuals who own 25% or more of the client's business. Always required for a Privately Owned Business. If Significant Ownership is selected as True, At least one related party should have the role of owner.
   */
  significantOwnership?: boolean;
  /**
   * Website of the business connected to the client. Always required if websiteAvailable is true.

   * @pattern ^((http|https|HTTP|HTTPS):\/\/)?(www.|WWW.)?(?!.*(http|HTTP|https|HTTPS|www.|WWW.))[a-zA-Z0-9_-]+(\.[a-zA-Z]+)+((\/)[\w#]+)*(\/\w+\?[a-zA-Z0-9_]+=\w+(&[a-zA-Z0-9_]+=\w+)*)?\/?$
   */
  website?: string;
  /** Whether or not the business connected to the client has a website.
   */
  websiteAvailable?: boolean;
  /**
   * Year of company formation. Max and Min length is 4.

   * @pattern ^(19|20)[0-9]+
   */
  yearOfFormation?: string;
};

export type PartyDetailBusiness = PartyDetailCommon & PartyDetailBusinessAllOf;

export type ClientInformationResponse = PartyDetailBusiness &
  ClientInformationResponseAllOf;

export interface IdentityDTO {
  /** Description of identification type e.g. Social Security Number */
  idDescription?: string;
  /** Identification issuer country code e.g. US */
  idIssuer: string;
  /** IdType denotes the type of taxpayer identification numbers e.g. SSN/EIN. EIN is acceptable idType for Privately Owned Business. Sole Proprietorship can have EIN/SSN as idType. For individuals like Owners and Controllers SSN is accepted as idType. Decision Makers do not require any tax identifier.
   */
  idType: string;
  /**
   * Value of the identification type. EIN/SSN must be of 9 digits.
   * @pattern [0-9A-Za-z-]+
   */
  idValue: string;
}

/**
 * Phone Number Information of the account

 */
export interface Phone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^(0{2}|\+)?[1-9]{1,3}$
   */
  countryCode: string;
  /**
   * @minLength 7
   * @maxLength 14
   * @pattern ^[0-9]{7,14}$
   */
  phoneNumber: string;
}

export interface AddressDto {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 34 characters. addressLine1 is mandatory when client is created.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 2
   * @pattern ^[a-z-A-Z ]+$
   */
  state?: string;
}

export interface PartyDetailCommon {
  address?: AddressDto;
  /**
   * @minItems 0
   * @maxItems 100
   */
  identities?: IdentityDTO[];
  phone?: Phone;
}

export interface PageMetaData {
  /** Number of records per page.
   */
  limit?: number;
  /** Page Number.
   */
  page?: number;
  /** Total number of items.
   */
  total_items?: number;
}

export interface ListWebhookResponse {
  /**
   * List of webhooks you have created.
   * @minItems 0
   * @maxItems 256
   */
  items: WebhookResponse[];
  metadata: PageMetaData;
}

export interface ListDocumentsDetailsResponse {
  items?: DocumentsDetailsArray;
  metadata?: PageMetaData;
}
